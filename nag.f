      SUBROUTINE D02CJF(T,TEND,NEQ,Y,FCN,TOL,RELABS,OUTPUT,G,RWORK,
     *                  IFAIL)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     MARK 14A REVISED.  IER-680 (DEC 1989).
C     .. Parameters ..
      CHARACTER*6       SRNAME
      PARAMETER         (SRNAME='D02CJF')
      DOUBLE PRECISION  RZERO, ONE, TEN, TENM7
      PARAMETER         (RZERO=0.0D0,ONE=1.0D0,TEN=10.0D0,TENM7=1.0D-7)
      INTEGER           MXREC
      PARAMETER         (MXREC=3)
C     .. Scalar Arguments ..
      DOUBLE PRECISION  T, TEND, TOL
      INTEGER           IFAIL, NEQ
      CHARACTER*1       RELABS
C     .. Array Arguments ..
      DOUBLE PRECISION  RWORK(28+21*NEQ), Y(NEQ)
C     .. Function Arguments ..
      DOUBLE PRECISION  G
      EXTERNAL          G
C     .. Subroutine Arguments ..
      EXTERNAL          FCN, OUTPUT
C     .. Scalars in Common ..
      DOUBLE PRECISION  DELSGN, FOURU, HOLD, SRBIG, SRU, SVTNEW, TLEFT,
     *                  TOLD, TROOTS, TSTAR, TWOU, U, U34, U78, XOLD,
     *                  XSAVE, ZERO
      INTEGER           IBEGIN, IINTEG, INFLOP, INIT, INROTP, IQUIT,
     *                  ITOL, ITSTOP, IVC, KGI, KLE4, KOLD, KORD, KPREV,
     *                  KROOTP, KSTEPS, NS
      LOGICAL           DISCOP, GSTOP, INTOUT, NEEDG, NEWGEQ, NORND,
     *                  PGSTOP, PHASE1, PSERCH, ROOT, ROOTS, SEARCH,
     *                  START, STIFF
      CHARACTER*6       GOPT, OUTOPT
C     .. Arrays in Common ..
      DOUBLE PRECISION  ALPHA(12), BETA(12), GI(11), GRWB(13), PSI(12),
     *                  SIG(13), V(12), W(12)
      INTEGER           IV(10)
C     .. Local Scalars ..
      DOUBLE PRECISION  GDUM, GWANT, HMAX, TLAST, TOUT, TOUT1, TSAVE,
     *                  TSTOP, TWANT, UROUND
      INTEGER           BADCMP, I, IDID, IERR, IGNEW, IGOLD, IGP, IGSC,
     *                  IGV, IINDXG, IMMR, INEEDG, IP, IPHI, IPHI3N,
     *                  IPHI4N, IPHI5N, IPRO, IREVCM, IROD, ISEE, ITGV,
     *                  ITK, ITLB, ITRB, IWT, IYP, IYPOUT, IYY, KWANT,
     *                  MAXNUM, NEQG, NFAIL, NREC, NSUCC
      CHARACTER*1       RELAB1
C     .. Local Arrays ..
      DOUBLE PRECISION  ATOL(1), RTOL(1)
      INTEGER           IWORK(22)
      CHARACTER*80      REC(MXREC)
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF
      INTEGER           P01ABF
      EXTERNAL          X02AJF, P01ABF
C     .. External Subroutines ..
      EXTERNAL          D02QFX, E04UDU
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, SIGN, SQRT
C     .. Common blocks ..
      COMMON            /AD02CJ/OUTOPT, GOPT
      COMMON            /AD02QF/ALPHA, BETA, PSI, V, W, SIG, GRWB, GI,
     *                  XOLD, HOLD, TOLD, XSAVE, TSTAR, TWOU, INIT,
     *                  IBEGIN, ITOL, IINTEG, ITSTOP, INFLOP, IQUIT, IV,
     *                  NS, KORD, KOLD, KSTEPS, KLE4, KPREV, IVC, KGI,
     *                  START, PHASE1, NORND, STIFF, INTOUT
      COMMON            /BD02QF/ZERO, U, FOURU, SRU, U34, U78, SRBIG,
     *                  DELSGN, TROOTS, TLEFT, SVTNEW, KROOTP, INROTP,
     *                  GSTOP, PGSTOP, ROOT, ROOTS, NEEDG, DISCOP,
     *                  NEWGEQ, SEARCH, PSERCH
C     .. Save statement ..
      SAVE              /AD02CJ/, /AD02QF/, /BD02QF/
C     .. Executable Statements ..
      IERR = 0
      NREC = 0
      IF (NEQ.LT.1) THEN
         IERR = 1
         NREC = NREC + 1
         WRITE (REC(NREC),FMT=99999) NEQ
      END IF
      IF (TOL.LE.RZERO) THEN
         IERR = 1
         NREC = NREC + 1
         WRITE (REC(NREC),FMT=99998) TOL
      END IF
      IF (T.EQ.TEND) THEN
         IERR = 1
         NREC = NREC + 1
         WRITE (REC(NREC),FMT=99997) T
      END IF
      IF (IERR.EQ.1) GO TO 220
      IDID = 0
      IBEGIN = 0
      ITOL = 0
      IINTEG = 0
      ITSTOP = 1
      TSTOP = TEND
      RWORK(1) = TEND
      IF (T.EQ.TEND) GO TO 220
      OUTOPT = 'YESOPT'
      TOUT = T
      CALL OUTPUT(TOUT,Y)
      IF (OUTOPT.EQ.'YESOPT') THEN
         IF (TOUT.EQ.T) THEN
            IERR = 4
            NREC = NREC + 1
            WRITE (REC(NREC),FMT=99988)
         ELSE IF (SIGN(ONE,TOUT-T).NE.SIGN(ONE,TEND-T)) THEN
            IERR = 4
            NREC = NREC + 1
            WRITE (REC(NREC),FMT=99987) TOUT
            NREC = NREC + 1
            WRITE (REC(NREC),FMT=99986) T, TEND
         END IF
         IF (IERR.EQ.4) GO TO 220
      ELSE
         TOUT = TEND
      END IF
      RTOL(1) = TOL
      ATOL(1) = TOL
      RELAB1 = RELABS
      CALL E04UDU(RELAB1)
      IF (RELAB1.EQ.'A') THEN
         RTOL(1) = RZERO
      ELSE IF (RELAB1.EQ.'R') THEN
         UROUND = X02AJF()
         ATOL(1) = MIN(SQRT(UROUND),MAX(TENM7,TEN*UROUND))
      ELSE IF (RELAB1.NE.'M' .AND. RELAB1.NE.'D') THEN
         IERR = 1
         NREC = NREC + 1
         WRITE (REC(NREC),FMT=99996) RELAB1
         GO TO 220
      END IF
C
C     COMPUTE THE INDICES FOR THE ARRAYS TO BE STORED IN THE WORK ARRAY
C
C                             -- REAL RWORK
C
      IYPOUT = 21
      IYP = NEQ + IYPOUT
      IYY = NEQ + IYP
      IWT = NEQ + IYY
      IP = NEQ + IWT
      IPHI = NEQ + IP
C
      IPHI3N = IPHI + 3*NEQ
      IPHI4N = IPHI + 4*NEQ
      IPHI5N = IPHI + 5*NEQ
C
      GOPT = 'YSGOPT'
      GDUM = G(T,Y)
      IF (GOPT.EQ.'YSGOPT') THEN
         NEQG = 1
         ISEE = 0
         NEWGEQ = .TRUE.
         SEARCH = .FALSE.
         GSTOP = .TRUE.
      ELSE
         GSTOP = .FALSE.
         SEARCH = .FALSE.
         NEQG = 0
         ISEE = 0
      END IF
      IGOLD = 16*NEQ + IPHI
      IGNEW = NEQG + IGOLD
      IGP = NEQG + IGNEW
      ITK = NEQG + IGP
      IPRO = NEQG + ITK
      IROD = NEQG*ISEE + IPRO
      ITGV = NEQG*ISEE + IROD
      IGV = 3*NEQG*ISEE + ITGV
      ITLB = 3*NEQG*ISEE + IGV
      ITRB = NEQG*ISEE + ITLB
C
C
C                             -- INTEGER IWORK
      IGSC = 21
      IINDXG = NEQG*ISEE + IGSC
      IMMR = NEQG*ISEE + IINDXG
      INEEDG = NEQG*ISEE + IMMR
      IQUIT = 0
C
      TLAST = T
      HMAX = RZERO
      MAXNUM = 1000
      NSUCC = 0
      NFAIL = 0
      TSAVE = TOUT
      IF (OUTOPT.EQ.'YESOUT' .AND. ABS(TOUT-T).GT.ABS(TEND-T))
     *    TOUT = TEND
      IF (NEQG.EQ.0) NEQG = 1
C
      IREVCM = 0
   20 CONTINUE
      CALL D02QFX(IREVCM,TWANT,KWANT,GWANT,NEQ,T,Y,TOUT,RTOL,ATOL,IDID,
     *            RWORK(IYPOUT),RWORK(IYP),RWORK(IYY),RWORK(IWT),
     *            RWORK(IP),RWORK(IPHI),RWORK(IGOLD),RWORK(IGNEW),
     *            RWORK(ITGV),RWORK(IGV),RWORK(IGP),RWORK(ITK),
     *            RWORK(ITLB),RWORK(ITRB),RWORK(IPRO),RWORK(IROD),
     *            RWORK(1),RWORK(11),RWORK(12),RWORK(13),HMAX,MAXNUM,
     *            NSUCC,NFAIL,IWORK(IINDXG),IWORK(IGSC),IWORK(IMMR),
     *            IWORK(INEEDG),IWORK(11),IWORK(12),NEQG,BADCMP)
C
      GO TO (40,40,60,80,80,100,120,20,140,140,
     *       180,180) IREVCM
      GO TO 200
C
   40 CONTINUE
      CALL FCN(TWANT,Y,RWORK(IYPOUT))
      GO TO 20
   60 CONTINUE
      CALL FCN(TWANT,RWORK(IYY),RWORK(IPHI5N))
      GO TO 20
   80 CONTINUE
      CALL FCN(TWANT,RWORK(IPHI3N),RWORK(IPHI4N))
      GO TO 20
  100 CONTINUE
      CALL FCN(TWANT,RWORK(IP),RWORK(IYP))
      GO TO 20
  120 CONTINUE
      CALL FCN(TWANT,RWORK(IYY),RWORK(IYP))
      GO TO 20
  140 CONTINUE
      DO 160 I = 1, NEQG
         RWORK(IGOLD+I-1) = G(TWANT,Y)
  160 CONTINUE
      GO TO 20
  180 CONTINUE
      GWANT = G(TWANT,Y)
      GO TO 20
C
  200 CONTINUE
      IF (IDID.EQ.2 .OR. IDID.EQ.3) THEN
         IF (TOUT.NE.TEND) THEN
            TOUT1 = TOUT
            CALL OUTPUT(TOUT,Y)
            IF (TOUT.EQ.TOUT1) THEN
               IERR = 5
               NREC = NREC + 1
               WRITE (REC(NREC),FMT=99985) TOUT
            ELSE IF (SIGN(ONE,TOUT-TOUT1).NE.SIGN(ONE,TEND-TOUT1)) THEN
               IERR = 5
               NREC = NREC + 1
               WRITE (REC(NREC),FMT=99984) TOUT
               NREC = NREC + 1
               WRITE (REC(NREC),FMT=99983) TOUT1, TEND
            ELSE
               TSAVE = TOUT
               IF (ABS(TOUT-T).GT.ABS(TEND-T)) TOUT = TEND
               GO TO 20
            END IF
         ELSE IF (TSAVE.EQ.TEND) THEN
            CALL OUTPUT(TOUT,Y)
         END IF
         IF (GOPT.EQ.'YSGOPT') THEN
            IERR = 6
            NREC = NREC + 1
            WRITE (REC(NREC),FMT=99995)
            NREC = NREC + 1
            WRITE (REC(NREC),FMT=99994)
         END IF
      ELSE IF (IDID.EQ.-1 .OR. IDID.EQ.-4) THEN
         IBEGIN = 1
         GO TO 20
      ELSE IF (IDID.EQ.-2) THEN
         IF (T.EQ.TLAST) THEN
            IERR = 3
            NREC = NREC + 1
            WRITE (REC(NREC),FMT=99993)
            NREC = NREC + 1
            WRITE (REC(NREC),FMT=99992) TOL
         ELSE
            IERR = 2
            NREC = NREC + 1
            WRITE (REC(NREC),FMT=99991) T
            NREC = NREC + 1
            WRITE (REC(NREC),FMT=99990) TOL
         END IF
      ELSE IF (IDID.LT.3) THEN
         IERR = 7
         NREC = NREC + 1
         WRITE (REC(NREC),FMT=99989) IDID
      END IF
  220 IFAIL = P01ABF(IFAIL,IERR,SRNAME,NREC,REC)
      RETURN
C
99999 FORMAT (' ** N .lt. 1. N = ',I16,'.')
99998 FORMAT (' ** TOL .le. 0.0. TOL = ',1P,D13.5,'.')
99997 FORMAT (' ** X .eq. XEND. X = ',1P,D13.5,'.')
99996 FORMAT (' ** RELABS .NE. ''M'',''A'',''R'' or ''D''. RELABS = ',
     *       A1,'.')
99995 FORMAT (' ** No change in sign of the function G(T,Y) was detect',
     *       'ed ')
99994 FORMAT ('    in the integration range.')
99993 FORMAT (' ** No integration steps have been taken. Progress not ',
     *       'possible with the ')
99992 FORMAT ('    input value of TOL,',1P,D13.5,'.')
99991 FORMAT (' ** Integration successful as far as T = ',1P,D13.5,', ',
     *       'but further progress')
99990 FORMAT ('    not possible with the input value of TOL,',1P,D13.5,
     *       '.')
99989 FORMAT (' ** Impossible error - internal variable IDID = ',I16,
     *       '.')
99988 FORMAT (' ** On the first call to OUTPUT, XSOL remained unchange',
     *       'd.')
99987 FORMAT (' ** On the first call to OUTPUT, XSOL was returned as ',
     *       1P,D13.5,',')
99986 FORMAT ('    which is inconsistent with (X,XEND) - (',1P,D13.5,
     *       ',',D13.5,').')
99985 FORMAT (' ** On a call to OUTPUT, XSOL remained unchanged. XSOL ',
     *       '= ',1P,D13.5,'.')
99984 FORMAT (' ** On a call to OUTPUT, XSOL was returned as ',1P,D13.5,
     *       ', which is')
99983 FORMAT ('    inconsistent with previous XSOL and XEND - (',1P,
     *       D13.5,',',D13.5,').')
      END
      DOUBLE PRECISION FUNCTION D02CJW(RDUM1,RDUM2)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     .. Parameters ..
      DOUBLE PRECISION                 ZERO
      PARAMETER                        (ZERO=0.0D0)
C     .. Scalar Arguments ..
      DOUBLE PRECISION                 RDUM1, RDUM2
C     .. Scalars in Common ..
      CHARACTER*6                      CHDUM, GOPT
C     .. Common blocks ..
      COMMON                           /AD02CJ/CHDUM, GOPT
C     .. Save statement ..
      SAVE                             /AD02CJ/
C     .. Executable Statements ..
      D02CJW = ZERO
      GOPT = 'NOGOPT'
      RETURN
      END
      SUBROUTINE D02CJX(RDUM1,RDUM2)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     .. Scalar Arguments ..
      DOUBLE PRECISION  RDUM1, RDUM2
C     .. Scalars in Common ..
      CHARACTER*6       CHDUM, OUTOPT
C     .. Common blocks ..
      COMMON            /AD02CJ/OUTOPT, CHDUM
C     .. Save statement ..
      SAVE              /AD02CJ/
C     .. Executable Statements ..
      OUTOPT = 'NOXOUT'
      RETURN
      END
      DOUBLE PRECISION FUNCTION D02QFN(V,NCOMP)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C
C     COMPUTE THE MAXIMUM NORM OF THE VECTOR V(*) OF LENGTH NCOMP AND
C     RETURN THE RESULT AS D02QFNM.
C
C
C     .. Scalar Arguments ..
      INTEGER                          NCOMP
C     .. Array Arguments ..
      DOUBLE PRECISION                 V(NCOMP)
C     .. Local Scalars ..
      INTEGER                          K
C     .. Intrinsic Functions ..
      INTRINSIC                        ABS, MAX
C     .. Executable Statements ..
      D02QFN = 0.D0
      DO 20 K = 1, NCOMP
         D02QFN = MAX(D02QFN,ABS(V(K)))
   20 CONTINUE
      RETURN
C
C
C     END OF D02QFN (VNORM)
C
C
      END
      SUBROUTINE D02QFP(IREVCM,NEQ,TWANT,B,Y,YPRIME,ETOL,MORDER,SMALL,
     *                  BIG,SPY,PV,YP,SF,H)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C
C     D02QFP COMPUTES A STARTING STEP SIZE TO BE USED IN SOLVING INITIAL
C     VALUE PROBLEMS IN ORDINARY DIFFERENTIAL EQUATIONS.
C     ******************************************************************
C
C     ABSTRACT
C
C     SUBROUTINE D02QFP COMPUTES A STARTING STEP SIZE TO BE USED BY AN
C     INITIAL VALUE METHOD IN SOLVING ORDINARY DIFFERENTIAL EQUATIONS.
C     IT IS BASED ON AN ESTIMATE OF THE LOCAL LIPSCHITZ CONSTANT FOR THE
C     DIFFERENTIAL EQUATION   (LOWER BOUND ON A NORM OF THE JACOBIAN) ,
C     A BOUND ON THE DIFFERENTIAL EQUATION  (FIRST DERIVATIVE) , AND
C     A BOUND ON THE PARTIAL DERIVATIVE OF THE EQUATION WITH RESPECT TO
C     THE INDEPENDENT VARIABLE.
C     (ALL APPROXIMATED NEAR THE INITIAL POINT A)
C
C     SUBROUTINE D02QFP USES A FUNCTION SUBPROGRAM D02QFN FOR COMPUTING
C     A VECTOR NORM. THE MAXIMUM NORM IS PRESENTLY UTILIZED THOUGH IT
C     CAN EASILY BE REPLACED BY ANY OTHER VECTOR NORM. IT IS PRESUMED
C     THAT ANY REPLACEMENT NORM ROUTINE WOULD BE CAREFULLY CODED TO
C     PREVENT UNNECESSARY UNDERFLOWS OR OVERFLOWS FROM OCCURRING, AND
C     ALSO, WOULD NOT ALTER THE VECTOR OR NUMBER OF COMPONENTS.
C
C     *****************************************************************
C     ON INPUT YOU MUST PROVIDE THE FOLLOWING
C
C      F   -- THIS IS A SUBROUTINE OF THE FORM
C                               F(X,U,UPRIME,RPAR,IPAR)
C             WHICH DEFINES THE SYSTEM OF FIRST ORDER DIFFERENTIAL
C             EQUATIONS TO BE SOLVED. FOR THE GIVEN VALUES OF X AND THE
C             VECTOR  U(*)=(U(1),U(2),...,U(NEQ)) , THE SUBROUTINE MUST
C             EVALUATE THE NEQ COMPONENTS OF THE SYSTEM OF DIFFERENTIAL
C             EQUATIONS  DU/DX=F(X,U)  AND STORE THE DERIVATIVES IN THE
C             ARRAY UPRIME(*), THAT IS,  UPRIME(I) = * DU(I)/DX *  FOR
C             EQUATIONS I=1,...,NEQ.
C
C             SUBROUTINE F MUST NOT ALTER X OR U(*). YOU MUST DECLARE
C             THE NAME F IN AN EXTERNAL STATEMENT IN YOUR PROGRAM THAT
C             CALLS D02QFP. YOU MUST DIMENSION U AND UPRIME IN F.
C
C             RPAR AND IPAR ARE REAL AND INTEGER PARAMETER ARRAYS WHICH
C             YOU CAN USE FOR COMMUNICATION BETWEEN YOUR PROGRAM AND
C             SUBROUTINE F. THEY ARE NOT USED OR ALTERED BY D02QFP. IF
C             YOU DO NOT NEED RPAR OR IPAR, IGNORE THESE PARAMETERS BY
C             TREATING THEM AS DUMMY ARGUMENTS. IF YOU DO CHOOSE TO USE
C             THEM, DIMENSION THEM IN YOUR PROGRAM AND IN F AS ARRAYS
C             OF APPROPRIATE LENGTH.
C
C      NEQ -- THIS IS THE NUMBER OF (FIRST ORDER) DIFFERENTIAL EQUATIONS
C             TO BE INTEGRATED.
C
C      A   -- THIS IS THE INITIAL POINT OF INTEGRATION.
C
C      B   -- THIS IS A VALUE OF THE INDEPENDENT VARIABLE USED TO DEFINE
C             THE DIRECTION OF INTEGRATION. A REASONABLE CHOICE IS TO
C             SET  B  TO THE FIRST POINT AT WHICH A SOLUTION IS DESIRED.
C             YOU CAN ALSO USE  B, IF NECESSARY, TO RESTRICT THE LENGTH
C             OF THE FIRST INTEGRATION STEP BECAUSE THE ALGORITHM WILL
C             NOT COMPUTE A STARTING STEP LENGTH WHICH IS BIGGER THAN
C             ABS(B-A), UNLESS  B  HAS BEEN CHOSEN TOO CLOSE TO  A.
C             (IT IS PRESUMED THAT D02QFP HAS BEEN CALLED WITH  B
C             DIFFERENT FROM  A  ON THE MACHINE BEING USED. ALSO SEE THE
C             DISCUSSION ABOUT THE PARAMETER  SMALL.)
C
C      Y(*) -- THIS IS THE VECTOR OF INITIAL VALUES OF THE NEQ SOLUTION
C             COMPONENTS AT THE INITIAL POINT  A.
C
C      YPRIME(*) -- THIS IS THE VECTOR OF DERIVATIVES OF THE NEQ
C             SOLUTION COMPONENTS AT THE INITIAL POINT  A.
C             (DEFINED BY THE DIFFERENTIAL EQUATIONS IN SUBROUTINE F)
C
C      ETOL -- THIS IS THE VECTOR OF ERROR TOLERANCES CORRESPONDING TO
C             THE NEQ SOLUTION COMPONENTS. IT IS ASSUMED THAT ALL
C             ELEMENTS ARE POSITIVE. FOLLOWING THE FIRST INTEGRATION
C             STEP, THE TOLERANCES ARE EXPECTED TO BE USED BY THE
C             INTEGRATOR IN AN ERROR TEST WHICH ROUGHLY REQUIRES THAT
C                        ABS(LOCAL ERROR) .LE. ETOL
C             FOR EACH VECTOR COMPONENT.
C
C      MORDER -- THIS IS THE ORDER OF THE FORMULA WHICH WILL BE USED BY
C             THE INITIAL VALUE METHOD FOR TAKING THE FIRST INTEGRATION
C             STEP.
C
C      SMALL -- THIS IS A SMALL POSITIVE MACHINE DEPENDENT CONSTANT
C             WHICH IS USED FOR PROTECTING AGAINST COMPUTATIONS WITH
C             NUMBERS WHICH ARE TOO SMALL RELATIVE TO THE PRECISION OF
C             FLOATING POINT ARITHMETIC.  SMALL  SHOULD BE SET TO
C             (APPROXIMATELY) THE SMALLEST POSITIVE REAL NUMBER SUCH
C             THAT  (1.+SMALL) .GT. 1.  ON THE MACHINE BEING USED. THE
C             QUANTITY  SMALL**(3/8)  IS USED IN COMPUTING INCREMENTS OF
C             VARIABLES FOR APPROXIMATING DERIVATIVES BY DIFFERENCES.
C             ALSO THE ALGORITHM WILL NOT COMPUTE A STARTING STEP LENGTH
C             WHICH IS SMALLER THAN  100*SMALL*ABS(A).
C
C      BIG -- THIS IS A LARGE POSITIVE MACHINE DEPENDENT CONSTANT WHICH
C             IS USED FOR PREVENTING MACHINE OVERFLOWS. A REASONABLE
C             CHOICE IS TO SET BIG TO (APPROXIMATELY) THE SQUARE ROOT OF
C             THE LARGEST REAL NUMBER WHICH CAN BE HELD IN THE MACHINE.
C
C      SPY(*),PV(*),YP(*),SF(*) -- THESE ARE REAL WORK ARRAYS OF LENGTH
C             NEQ WHICH PROVIDE THE ROUTINE WITH NEEDED STORAGE SPACE.
C
C      RPAR,IPAR -- THESE ARE PARAMETER ARRAYS, OF REAL AND INTEGER
C             TYPE, RESPECTIVELY, WHICH CAN BE USED FOR COMMUNICATION
C             BETWEEN YOUR PROGRAM AND THE F SUBROUTINE. THEY ARE NOT
C             USED OR ALTERED BY D02QFP.
C
C     *****************************************************************
C     ON OUTPUT  (AFTER THE RETURN FROM D02QFP),
C
C      H -- IS AN APPROPRIATE STARTING STEP SIZE TO BE ATTEMPTED BY THE
C             DIFFERENTIAL EQUATION METHOD.
C
C           ALL PARAMETERS IN THE CALL LIST REMAIN UNCHANGED EXCEPT FOR
C           THE WORKING ARRAYS SPY(*),PV(*),YP(*) AND SF(*).
C
C     *****************************************************************
C
C     REVISION DATE  861016   (YYMMDD)
C
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  B, BIG, H, SMALL, TWANT
      INTEGER           IREVCM, MORDER, NEQ
C     .. Array Arguments ..
      DOUBLE PRECISION  ETOL(NEQ), PV(NEQ), SF(NEQ), SPY(NEQ), Y(NEQ),
     *                  YP(NEQ), YPRIME(NEQ)
C     .. Scalars in Common ..
      DOUBLE PRECISION  A, ABSDX, DA, DELX, DFDUB, DFDXB, DX, FBND,
     *                  POWER, RELPER, YNORM, YPNORM
      INTEGER           ICASE, K, LK
C     .. Local Scalars ..
      DOUBLE PRECISION  DELF, DELXB, DELY, DY, SRYDPB, WTJ, YDPB
      INTEGER           J
C     .. External Functions ..
      DOUBLE PRECISION  D02QFN
      EXTERNAL          D02QFN
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, DBLE, SIGN, SQRT
C     .. Common blocks ..
      COMMON            /JD02QF/A, ABSDX, DA, DELX, DFDUB, DFDXB, DX,
     *                  FBND, POWER, RELPER, YNORM, YPNORM, ICASE, K, LK
C     .. Save statement ..
      SAVE              /JD02QF/
C     .. Executable Statements ..
C
C     ..................................................................
C
      GO TO (20,320,380) IREVCM - 2
      A = TWANT
      DX = B - A
      ABSDX = ABS(DX)
      RELPER = SMALL**0.375D0
C     YNORM = VNORM(Y,NEQ)
      YNORM = D02QFN(Y,NEQ)
C
C     ..................................................................
C
C     COMPUTE A WEIGHTED APPROXIMATE BOUND (DFDXB) ON THE PARTIAL
C     DERIVATIVE OF THE EQUATION WITH RESPECT TO THE
C     INDEPENDENT VARIABLE. PROTECT AGAINST AN OVERFLOW. ALSO
C     COMPUTE A WEIGHTED BOUND (FBND) ON THE FIRST DERIVATIVE LOCALLY.
C
      DA = SIGN(MAX(MIN(RELPER*ABS(A),ABSDX),100.D0*SMALL*ABS(A)),DX)
      IF (DA.EQ.0.D0) DA = RELPER*DX
C     CALL F(A+DA,Y,SF,RPAR,IPAR)
      IREVCM = 3
      TWANT = A + DA
      RETURN
   20 CONTINUE
      IREVCM = 0
C
      IF (MORDER.EQ.1) GO TO 60
      POWER = 2.D0/DBLE(MORDER+1)
      DO 40 J = 1, NEQ
         WTJ = ETOL(J)**POWER
         SPY(J) = SF(J)/WTJ
         YP(J) = YPRIME(J)/WTJ
         PV(J) = SPY(J) - YP(J)
   40 CONTINUE
      GO TO 100
C
   60 DO 80 J = 1, NEQ
         SPY(J) = SF(J)/ETOL(J)
         YP(J) = YPRIME(J)/ETOL(J)
         PV(J) = SPY(J) - YP(J)
   80 CONTINUE
C
C     100 DELF = VNORM(PV,NEQ)
  100 DELF = D02QFN(PV,NEQ)
      DFDXB = BIG
      IF (DELF.LT.BIG*ABS(DA)) DFDXB = DELF/ABS(DA)
C     YPNORM = VNORM(YP,NEQ)
      YPNORM = D02QFN(YP,NEQ)
C     FBND = MAX(VNORM(SPY,NEQ),YPNORM)
      FBND = MAX(D02QFN(SPY,NEQ),YPNORM)
C
C     ..................................................................
C
C     COMPUTE AN ESTIMATE (DFDUB) OF THE LOCAL LIPSCHITZ CONSTANT FOR
C     THE SYSTEM OF DIFFERENTIAL EQUATIONS. THIS ALSO REPRESENTS AN
C     ESTIMATE OF THE NORM OF THE JACOBIAN LOCALLY.
C     THREE ITERATIONS (TWO WHEN NEQ=1) ARE USED TO ESTIMATE THE
C     LIPSCHITZ CONSTANT BY NUMERICAL DIFFERENCES. THE FIRST
C     PERTURBATION VECTOR IS BASED ON THE INITIAL DERIVATIVES AND
C     DIRECTION OF INTEGRATION. THE SECOND PERTURBATION VECTOR IS
C     FORMED USING ANOTHER EVALUATION OF THE DIFFERENTIAL EQUATION.
C     THE THIRD PERTURBATION VECTOR IS FORMED USING PERTURBATIONS BASED
C     ONLY ON THE INITIAL VALUES. COMPONENTS THAT ARE ZERO ARE ALWAYS
C     CHANGED TO NON-ZERO VALUES (EXCEPT ON THE FIRST ITERATION). WHEN
C     INFORMATION IS AVAILABLE, CARE IS TAKEN TO ENSURE THAT COMPONENTS
C     OF THE PERTURBATION VECTOR HAVE SIGNS WHICH ARE CONSISTENT WITH
C     THE SLOPES OF LOCAL SOLUTION CURVES.
C     ALSO CHOOSE THE LARGEST BOUND (FBND) FOR THE FIRST DERIVATIVE.
C     NO ATTEMPT IS MADE TO KEEP THE PERTURBATION VECTOR SIZE CONSTANT.
C
      IF (YPNORM.EQ.0.D0) GO TO 140
C                       USE INITIAL DERIVATIVES FOR FIRST PERTURBATION
      ICASE = 1
      DO 120 J = 1, NEQ
         SPY(J) = YPRIME(J)
         YP(J) = YPRIME(J)
  120 CONTINUE
      GO TO 180
C                       CANNOT HAVE A NULL PERTURBATION VECTOR
  140 ICASE = 2
      DO 160 J = 1, NEQ
         SPY(J) = YPRIME(J)
         YP(J) = ETOL(J)
  160 CONTINUE
C
  180 DFDUB = 0.D0
      LK = MIN(NEQ+1,3)
C     DO 260 K=1,LK
      K = 0
  200 K = K + 1
C                       SET YPNORM AND DELX
C     YPNORM = VNORM(YP,NEQ)
      YPNORM = D02QFN(YP,NEQ)
      IF (ICASE.EQ.1 .OR. ICASE.EQ.3) GO TO 220
      DELX = SIGN(1.0D0,DX)
      GO TO 280
C                       TRY TO ENFORCE MEANINGFUL PERTURBATION VALUES
  220 DELX = DX
      IF (ABS(DELX)*YPNORM.GE.RELPER*YNORM) GO TO 240
      DELXB = BIG
      IF (RELPER*YNORM.LT.BIG*YPNORM) DELXB = RELPER*YNORM/YPNORM
      DELX = SIGN(DELXB,DX)
  240 DO 260 J = 1, NEQ
         IF (ABS(DELX*YP(J)).GT.ETOL(J)) DELX = SIGN(ETOL(J)/YP(J),DX)
  260 CONTINUE
C                       DEFINE PERTURBED VECTOR OF INITIAL VALUES
  280 DO 300 J = 1, NEQ
         PV(J) = Y(J) + DELX*YP(J)
  300 CONTINUE
      IF (K.EQ.2) GO TO 360
C                       EVALUATE DERIVATIVES ASSOCIATED WITH PERTURBED
C                       VECTOR  AND  COMPUTE CORRESPONDING DIFFERENCES
C       CALL F(A,PV,YP,RPAR,IPAR)
      IREVCM = 4
      TWANT = A
      RETURN
  320 CONTINUE
      IREVCM = 0
      DO 340 J = 1, NEQ
         PV(J) = YP(J) - YPRIME(J)
  340 CONTINUE
      GO TO 420
C                       USE A SHIFTED VALUE OF THE INDEPENDENT VARIABLE
C                                             IN COMPUTING ONE ESTIMATE
C     150   CALL F(A+DA,PV,YP,RPAR,IPAR)
  360 CONTINUE
      IREVCM = 5
      TWANT = A + DA
      RETURN
  380 CONTINUE
      IREVCM = 0
      DO 400 J = 1, NEQ
         PV(J) = YP(J) - SF(J)
  400 CONTINUE
C                       CHOOSE LARGEST BOUND ON THE WEIGHTED FIRST
C                                                   DERIVATIVE
  420 IF (MORDER.EQ.1) GO TO 460
      DO 440 J = 1, NEQ
         YP(J) = YP(J)/ETOL(J)**POWER
  440 CONTINUE
      GO TO 500
  460 DO 480 J = 1, NEQ
         YP(J) = YP(J)/ETOL(J)
  480 CONTINUE
C     500 FBND = MAX(FBND,VNORM(YP,NEQ))
  500 FBND = MAX(FBND,D02QFN(YP,NEQ))
C                       COMPUTE BOUND ON A LOCAL LIPSCHITZ CONSTANT
C     DELF = VNORM(PV,NEQ)
      DELF = D02QFN(PV,NEQ)
      IF (DELF.EQ.0.D0) GO TO 520
      DELY = ABS(DELX)*YPNORM
      IF (DELF.GE.BIG*DELY) GO TO 600
      DFDUB = MAX(DFDUB,DELF/DELY)
C
  520 IF (K.EQ.LK) GO TO 620
C                       CHOOSE NEXT PERTURBATION VECTOR
      DO 580 J = 1, NEQ
         IF (K.EQ.LK-1) GO TO 540
         ICASE = 3
         DY = ABS(PV(J))
         IF (DY.EQ.0.D0) DY = MAX(DELF,ETOL(J))
         GO TO 560
  540    ICASE = 4
         DY = MAX(RELPER*ABS(Y(J)),ETOL(J))
  560    IF (SPY(J).EQ.0.D0) SPY(J) = YP(J)
         IF (SPY(J).NE.0.D0) DY = SIGN(DY,SPY(J))
         YP(J) = DY
  580 CONTINUE
C     260   CONTINUE
      IF (K.LT.LK) GO TO 200
C
C                       PROTECT AGAINST AN OVERFLOW
  600 DFDUB = BIG
C
C     ..................................................................
C
C     COMPUTE A BOUND (YDPB) ON THE NORM OF THE SECOND DERIVATIVE
C
  620 YDPB = DFDXB + DFDUB*FBND
C
C     ..................................................................
C
C     COMPUTE A STARTING STEP SIZE BASED ON THE ABOVE FIRST AND SECOND
C     DERIVATIVE INFORMATION
C
C                       RESTRICT THE STEP LENGTH TO BE NOT BIGGER THAN
C                       ABS(B-A).   (UNLESS  B  IS TOO CLOSE TO  A)
      H = ABSDX
C
      IF (YDPB.NE.0.D0 .OR. FBND.NE.0.D0) GO TO 640
C
C                       BOTH FIRST DERIVATIVE TERM (FBND) AND SECOND
C                                    DERIVATIVE TERM (YDPB) ARE ZERO
      GO TO 680
C
  640 IF (YDPB.NE.0.D0) GO TO 660
C
C                       ONLY SECOND DERIVATIVE TERM (YDPB) IS ZERO
      IF (1.0D0.LT.FBND*ABSDX) H = 1.D0/FBND
      GO TO 680
C
C                       SECOND DERIVATIVE TERM (YDPB) IS NON-ZERO
  660 SRYDPB = SQRT(0.5D0*YDPB)
      IF (1.0D0.LT.SRYDPB*ABSDX) H = 1.D0/SRYDPB
C
C                       FURTHER RESTRICT THE STEP LENGTH TO BE NOT
C                                                 BIGGER THAN  1/DFDUB
  680 IF (H*DFDUB.GT.1.D0) H = 1.D0/DFDUB
C
C                       FINALLY, RESTRICT THE STEP LENGTH TO BE NOT
C                       SMALLER THAN  100*SMALL*ABS(A).  HOWEVER, IF
C                       A=0. AND THE COMPUTED H UNDERFLOWED TO ZERO,
C                       THE ALGORITHM RETURNS  SMALL*ABS(B)  FOR THE
C                                                       STEP LENGTH.
      H = MAX(H,100.D0*SMALL*ABS(A))
      IF (H.EQ.0.D0) H = SMALL*ABS(B)
C
C                       NOW SET DIRECTION OF INTEGRATION
      H = SIGN(H,DX)
C
      RETURN
C
C
C     END OF D02QFP (HSTART)
C
C
      END
      SUBROUTINE D02QFQ(IREVCM,TWANT,NEQN,Y,X,H,EPS,WT,START,HOLD,K,
     *                  KOLD,CRASH,PHI,P,YP,PSI,ALPHA,BETA,SIG,V,W,G,
     *                  PHASE1,NS,NORND,KSTEPS,TWOU,FOURU,XOLD,KPREV,
     *                  IVC,IV,KGI,GI,NSUCC,NFAIL)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C     PURPOSE
C     =======
C     INTEGRATES A SYSTEM OF FIRST ORDER ODES ONE STEP.
C
C     DESCRIPTION
C     ===========
C     WRITTEN BY L. F. SHAMPINE AND M. K. GORDON
C
C     ABSTRACT
C
C     SUBROUTINE D02QFQ INTEGRATES A SYSTEM OF  NEQN  FIRST ORDER
C     ORDINARY DIFFERENTIAL EQUATIONS ONE STEP, NORMALLY FROM X TO X+H,
C     USING A MODIFIED DIVIDED DIFFERENCE FORM OF THE ADAMS PECE
C     FORMULAS.  LOCAL EXTRAPOLATION IS USED TO IMPROVE ABSOLUTE
C     STABILITY AND ACCURACY. THE CODE ADJUSTS ITS ORDER AND STEP SIZE
C     TO CONTROL THE LOCAL ERROR  PER UNIT STEP IN A GENERALIZED SENSE.
C     SPECIAL DEVICES ARE INCLUDED TO CONTROL ROUNDOFF ERROR AND TO
C     DETECT WHEN THE USER IS REQUESTING TOO MUCH ACCURACY.
C
C     THIS CODE IS COMPLETELY EXPLAINED AND DOCUMENTED IN THE TEXT,
C     COMPUTER SOLUTION OF ORDINARY DIFFERENTIAL EQUATIONS, THE INITIAL
C     VALUE PROBLEM  BY L. F. SHAMPINE AND M. K. GORDON.
C     FURTHER DETAILS ON USE OF THIS CODE ARE AVAILABLE IN *SOLVING
C     ORDINARY DIFFERENTIAL EQUATIONS WITH ODE, STEP, AND INTRP*,
C     BY L. F. SHAMPINE AND M. K. GORDON, SLA-73-1060.
C
C
C     THE PARAMETERS REPRESENT --
C      F -- SUBROUTINE TO EVALUATE DERIVATIVES
C      NEQN -- NUMBER OF EQUATIONS TO BE INTEGRATED
C      Y(*) -- SOLUTION VECTOR AT X
C      X -- INDEPENDENT VARIABLE
C      H -- APPROPRIATE STEP SIZE FOR NEXT STEP.  NORMALLY DETERMINED BY
C           CODE
C      EPS -- LOCAL ERROR TOLERANCE
C      WT(*) -- VECTOR OF WEIGHTS FOR ERROR CRITERION
C      START -- LOGICAL VARIABLE SET .TRUE. FOR FIRST STEP,  .FALSE.
C           OTHERWISE
C      HOLD -- STEP SIZE USED FOR LAST SUCCESSFUL STEP
C      K -- APPROPRIATE ORDER FOR NEXT STEP (DETERMINED BY CODE)
C      KOLD -- ORDER USED FOR LAST SUCCESSFUL STEP
C      CRASH -- LOGICAL VARIABLE SET .TRUE. WHEN NO STEP CAN BE TAKEN,
C           .FALSE. OTHERWISE.
C      YP(*) -- DERIVATIVE OF SOLUTION VECTOR AT  X  AFTER SUCCESSFUL
C           STEP
C      KSTEPS -- COUNTER ON ATTEMPTED STEPS
C      TWOU -- 2.*U WHERE U IS MACHINE UNIT ROUNDOFF QUANTITY
C      FOURU -- 4.*U WHERE U IS MACHINE UNIT ROUNDOFF QUANTITY
C      RPAR,IPAR -- PARAMETER ARRAYS WHICH YOU MAY CHOOSE TO USE
C            FOR COMMUNICATION BETWEEN YOUR PROGRAM AND SUBROUTINE F.
C            THEY ARE NOT ALTERED OR USED BY D02QFQ.
C     THE VARIABLES X,XOLD,KOLD,KGI AND IVC AND THE ARRAYS
C     Y,PHI,ALPHA,G,W,P,IV AND GI ARE REQUIRED FOR THE INTERPOLATION
C     SUBROUTINE D02QFR. THE REMAINING VARIABLES AND ARRAYS ARE
C     INCLUDED IN THE CALL LIST ONLY TO ELIMINATE LOCAL RETENTION
C     OF VARIABLES BETWEEN CALLS.
C
C     INPUT TO D02QFQ
C
C      FIRST CALL --
C
C     THE USER MUST PROVIDE STORAGE IN HIS CALLING PROGRAM FOR
C     ALL ARRAYS IN THE CALL LIST, NAMELY
C
C     DIMENSION Y(NEQN),WT(NEQN),PHI(NEQN,16),P(NEQN),YP(NEQN),PSI(12),
C     1  ALPHA(12),BETA(12),SIG(13),V(12),W(12),G(13),GI(11),IV(10),
C     2  RPAR(1),IPAR(1)
C                              --                --    **NOTE**
C
C     THE USER MUST ALSO DECLARE  START ,  CRASH ,  PHASE1  AND  NORND
C     LOGICAL VARIABLES AND  F  AN EXTERNAL SUBROUTINE, SUPPLY THE
C     SUBROUTINE  F(X,Y,YP)  TO EVALUATE
C      DY(I)/DX = YP(I) = F(X,Y(1),Y(2),...,Y(NEQN))
C     AND INITIALIZE ONLY THE FOLLOWING PARAMETERS.
C      NEQN -- NUMBER OF EQUATIONS TO BE INTEGRATED
C      Y(*) -- VECTOR OF INITIAL VALUES OF DEPENDENT VARIABLES
C      X -- INITIAL VALUE OF THE INDEPENDENT VARIABLE
C      H -- NOMINAL STEP SIZE INDICATING DIRECTION OF INTEGRATION
C           AND MAXIMUM SIZE OF STEP.  MUST BE VARIABLE
C      EPS -- LOCAL ERROR TOLERANCE PER STEP.  MUST BE VARIABLE
C      WT(*) -- VECTOR OF NON-ZERO WEIGHTS FOR ERROR CRITERION
C      START -- .TRUE.
C      YP(*) -- VECTOR OF INITIAL DERIVATIVE VALUES
C      KSTEPS -- SET KSTEPS TO ZERO
C      TWOU -- 2.*U WHERE U IS MACHINE UNIT ROUNDOFF QUANTITY
C      FOURU -- 4.*U WHERE U IS MACHINE UNIT ROUNDOFF QUANTITY
C     DEFINE U TO BE THE MACHINE UNIT ROUNDOFF QUANTITY BY CALLING
C     THE FUNCTION ROUTINE  R1MACH,  U = R1MACH(4), OR BY
C     COMPUTING U SO THAT U IS THE SMALLEST POSITIVE NUMBER SUCH
C     THAT 1.0+U .GT. 1.0.
C
C     D02QFQ  REQUIRES THAT THE L2 NORM OF THE VECTOR WITH COMPONENTS
C     LOCAL ERROR(L)/WT(L)  BE LESS THAN  EPS  FOR A SUCCESSFUL STEP.
C     THE ARRAY  WT  ALLOWS THE USER TO SPECIFY AN ERROR TEST
C     APPROPRIATE FOR HIS PROBLEM.  FOR EXAMPLE,
C      WT(L) = 1.0  SPECIFIES ABSOLUTE ERROR,
C            = ABS(Y(L))  ERROR RELATIVE TO THE MOST RECENT VALUE OF THE
C                 L-TH COMPONENT OF THE SOLUTION,
C            = ABS(YP(L))  ERROR RELATIVE TO THE MOST RECENT VALUE OF
C                 THE L-TH COMPONENT OF THE DERIVATIVE,
C            = AMAX1(WT(L),ABS(Y(L)))  ERROR RELATIVE TO THE LARGEST
C                 MAGNITUDE OF L-TH COMPONENT OBTAINED SO FAR,
C            = ABS(Y(L))*RELERR/EPS + ABSERR/EPS  SPECIFIES A MIXED
C                 RELATIVE-ABSOLUTE TEST WHERE  RELERR  IS RELATIVE
C                 ERROR,  ABSERR  IS ABSOLUTE ERROR AND  EPS =
C                 AMAX1(RELERR,ABSERR) .
C
C      SUBSEQUENT CALLS --
C
C     SUBROUTINE  D02QFQ  IS DESIGNED SO THAT ALL INFORMATION NEEDED TO
C     CONTINUE THE INTEGRATION, INCLUDING THE STEP SIZE H  AND THE ORDER
C     K , IS RETURNED WITH EACH STEP.  WITH THE EXCEPTION OF THE STEP
C     SIZE, THE ERROR TOLERANCE, AND THE WEIGHTS, NONE OF THE PARAMETERS
C     SHOULD BE ALTERED.  THE ARRAY  WT  MUST BE UPDATED AFTER EACH STEP
C     TO MAINTAIN RELATIVE ERROR TESTS LIKE THOSE ABOVE.  NORMALLY THE
C     INTEGRATION IS CONTINUED JUST BEYOND THE DESIRED ENDPOINT AND THE
C     SOLUTION INTERPOLATED THERE WITH SUBROUTINE  D02QFR .  IF IT IS
C     IMPOSSIBLE TO INTEGRATE BEYOND THE ENDPOINT, THE STEP SIZE MAY BE
C     REDUCED TO HIT THE ENDPOINT SINCE THE CODE WILL NOT TAKE A STEP
C     LARGER THAN THE  H  INPUT.  CHANGING THE DIRECTION OF INTEGRATION,
C     I.E., THE SIGN OF H , REQUIRES THE USER SET  START = .TRUE. BEFORE
C     CALLING D02QFQ  AGAIN.  THIS IS THE ONLY SITUATION IN WHICH  START
C     SHOULD BE ALTERED.
C
C     OUTPUT FROM D02QFQ
C
C      SUCCESSFUL STEP --
C
C     THE SUBROUTINE RETURNS AFTER EACH SUCCESSFUL STEP WITH  START  AND
C     CRASH  SET .FALSE. .  X  REPRESENTS THE INDEPENDENT VARIABLE
C     ADVANCED ONE STEP OF LENGTH  HOLD  FROM ITS VALUE ON INPUT AND  Y
C     THE SOLUTION VECTOR AT THE NEW VALUE OF  X .  ALL OTHER PARAMETERS
C     REPRESENT INFORMATION CORRESPONDING TO THE NEW  X  NEEDED TO
C     CONTINUE THE INTEGRATION.
C
C      UNSUCCESSFUL STEP --
C
C     WHEN THE ERROR TOLERANCE IS TOO SMALL FOR THE MACHINE PRECISION,
C     THE SUBROUTINE RETURNS WITHOUT TAKING A STEP AND  CRASH = .TRUE. .
C     AN APPROPRIATE STEP SIZE AND ERROR TOLERANCE FOR CONTINUING ARE
C     ESTIMATED AND ALL OTHER INFORMATION IS RESTORED AS UPON INPUT
C     BEFORE RETURNING.  TO CONTINUE WITH THE LARGER TOLERANCE, THE USER
C     JUST CALLS THE CODE AGAIN.  A RESTART IS NEITHER REQUIRED NOR
C     DESIRABLE.
C
C     REFERENCES
C     ==========
C                 SHAMPINE L.F., GORDON M.K., *SOLVING ORDINARY
C                 DIFFERENTIAL EQUATIONS WITH ODE, STEP, AND INTRP*,
C                 SLA-73-1060, SANDIA LABORATORIES, 1973.
C
C     DATE WRITTEN   740101   (YYMMDD)
C     REVISION DATE  840201   (YYMMDD)
C     AUTHOR  SHAMPINE, L.F.,  SNLA
C           GORDON, M.K.
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  EPS, FOURU, H, HOLD, TWANT, TWOU, X, XOLD
      INTEGER           IREVCM, IVC, K, KGI, KOLD, KPREV, KSTEPS, NEQN,
     *                  NFAIL, NS, NSUCC
      LOGICAL           CRASH, NORND, PHASE1, START
C     .. Array Arguments ..
      DOUBLE PRECISION  ALPHA(12), BETA(12), G(13), GI(11), P(NEQN),
     *                  PHI(NEQN,16), PSI(12), SIG(13), V(12), W(12),
     *                  WT(NEQN), Y(NEQN), YP(NEQN)
      INTEGER           IV(10)
C     .. Scalars in Common ..
      DOUBLE PRECISION  ABSH, BIG, ERK, ERKM1, P5EPS, ROUND, U
      INTEGER           IFAIL, KM1, KM2, KNEW, KP1, KP2
C     .. Arrays in Common ..
      DOUBLE PRECISION  GSTR(13), TWO(13)
C     .. Local Scalars ..
      DOUBLE PRECISION  ERKM2, ERKP1, ERR, HNEW, R, REALI, REALNS, RHO,
     *                  TAU, TEMP1, TEMP2, TEMP3, TEMP4, TEMP5, TEMP6
      INTEGER           I, IM1, IP1, IQ, J, JV, L, LIMIT1, LIMIT2, NSM2,
     *                  NSP1, NSP2
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AMF
      EXTERNAL          X02AJF, X02AMF
C     .. External Subroutines ..
      EXTERNAL          D02QFP
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, SIGN, SQRT
C     .. Common blocks ..
      COMMON            /KD02QF/TWO, GSTR, ABSH, BIG, ERK, ERKM1, P5EPS,
     *                  ROUND, U, IFAIL, KM1, KM2, KNEW, KP1, KP2
C     .. Save statement ..
      SAVE              /KD02QF/
C     .. Executable Statements ..
C
C
C       ***     BEGIN BLOCK 0     ***
C     CHECK IF STEP SIZE OR ERROR TOLERANCE IS TOO SMALL FOR MACHINE
C     PRECISION.  IF FIRST STEP, INITIALIZE PHI ARRAY AND ESTIMATE A
C     STARTING STEP SIZE.
C                   ***
C
C     IF STEP SIZE IS TOO SMALL, DETERMINE AN ACCEPTABLE ONE
C
      GO TO (100,100,100,660,1160,880) IREVCM - 2
      CRASH = .TRUE.
      IF (ABS(H).GE.FOURU*ABS(X)) GO TO 20
      H = SIGN(FOURU*ABS(X),H)
      RETURN
   20 P5EPS = 0.5D0*EPS
C
C     IF ERROR TOLERANCE IS TOO SMALL, INCREASE IT TO AN ACCEPTABLE
C     VALUE
C
      ROUND = 0.0D0
      DO 40 L = 1, NEQN
         ROUND = ROUND + (Y(L)/WT(L))**2
   40 CONTINUE
      ROUND = TWOU*SQRT(ROUND)
      IF (P5EPS.GE.ROUND) GO TO 60
      EPS = 2.0D0*ROUND*(1.0D0+FOURU)
      RETURN
   60 CRASH = .FALSE.
      G(1) = 1.0D0
      G(2) = 0.5D0
      SIG(1) = 1.0D0
      IF ( .NOT. START) GO TO 140
C
C     INITIALIZE.  COMPUTE APPROPRIATE STEP SIZE FOR FIRST STEP
C
C      CALL F(X,Y,YP,RPAR,IPAR)
C     SUM = 0.0
      TWO(1) = 2.0D0
      TWO(2) = 4.0D0
      TWO(3) = 8.0D0
      TWO(4) = 16.0D0
      TWO(5) = 32.0D0
      TWO(6) = 64.0D0
      TWO(7) = 128.0D0
      TWO(8) = 256.0D0
      TWO(9) = 512.0D0
      TWO(10) = 1024.0D0
      TWO(11) = 2048.0D0
      TWO(12) = 4096.0D0
      TWO(13) = 8192.0D0
      GSTR(1) = 0.5D0
      GSTR(2) = 0.0833D0
      GSTR(3) = 0.0417D0
      GSTR(4) = 0.0264D0
      GSTR(5) = 0.0188D0
      GSTR(6) = 0.0143D0
      GSTR(7) = 0.0114D0
      GSTR(8) = 0.00936D0
      GSTR(9) = 0.00789D0
      GSTR(10) = 0.00679D0
      GSTR(11) = 0.00592D0
      GSTR(12) = 0.00524D0
      GSTR(13) = 0.00468D0
      DO 80 L = 1, NEQN
         PHI(L,1) = YP(L)
         PHI(L,2) = 0.0D0
   80 CONTINUE
C     20     SUM = SUM + (YP(L)/WT(L))**2
C     SUM = SQRT(SUM)
C     ABSH = ABS(H)
C     IF(EPS .LT. 16.0*SUM*H*H) ABSH = 0.25*SQRT(EPS/SUM)
C     H = SIGN(AMAX1(ABSH,FOURU*ABS(X)),H)
C
C      U = R1MACH(4)
      U = X02AJF()
C      BIG = SQRT(R1MACH(2))
      BIG = SQRT(1.0D0/X02AMF())
      TWANT = X
  100 CONTINUE
C     CALL HSTART(IREVCM,NEQN,TWANT,X+H,Y,YP,WT,1,U,BIG,PHI(1,3),PHI(1,
C     *            4),PHI(1,5),PHI(1,6),H)
      CALL D02QFP(IREVCM,NEQN,TWANT,X+H,Y,YP,WT,1,U,BIG,PHI(1,3),PHI(1,
     *            4),PHI(1,5),PHI(1,6),H)
      IF (IREVCM.NE.0) RETURN
C
      HOLD = 0.0D0
      K = 1
      KOLD = 0
      KPREV = 0
      START = .FALSE.
      PHASE1 = .TRUE.
      NORND = .TRUE.
      IF (P5EPS.GT.100.0D0*ROUND) GO TO 140
      NORND = .FALSE.
      DO 120 L = 1, NEQN
         PHI(L,15) = 0.0D0
  120 CONTINUE
  140 IFAIL = 0
C       ***     END BLOCK 0     ***
C
C       ***     BEGIN BLOCK 1     ***
C     COMPUTE COEFFICIENTS OF FORMULAS FOR THIS STEP.  AVOID COMPUTING
C     THOSE QUANTITIES NOT CHANGED WHEN STEP SIZE IS NOT CHANGED.
C                   ***
C
  160 KP1 = K + 1
      KP2 = K + 2
      KM1 = K - 1
      KM2 = K - 2
C
C     NS IS THE NUMBER OF STEPS TAKEN WITH SIZE H, INCLUDING THE CURRENT
C     ONE.  WHEN K.LT.NS, NO COEFFICIENTS CHANGE
C
      IF (H.NE.HOLD) NS = 0
      IF (NS.LE.KOLD) NS = NS + 1
      NSP1 = NS + 1
      IF (K.LT.NS) GO TO 440
C
C     COMPUTE THOSE COMPONENTS OF ALPHA(*),BETA(*),PSI(*),SIG(*) WHICH
C     ARE CHANGED
C
      BETA(NS) = 1.0D0
      REALNS = NS
      ALPHA(NS) = 1.0D0/REALNS
      TEMP1 = H*REALNS
      SIG(NSP1) = 1.0D0
      IF (K.LT.NSP1) GO TO 200
      DO 180 I = NSP1, K
         IM1 = I - 1
         TEMP2 = PSI(IM1)
         PSI(IM1) = TEMP1
         BETA(I) = BETA(IM1)*PSI(IM1)/TEMP2
         TEMP1 = TEMP2 + H
         ALPHA(I) = H/TEMP1
         REALI = I
         SIG(I+1) = REALI*ALPHA(I)*SIG(I)
  180 CONTINUE
  200 PSI(K) = TEMP1
C
C     COMPUTE COEFFICIENTS G(*)
C
C     INITIALIZE V(*) AND SET W(*).
C
      IF (NS.GT.1) GO TO 240
      DO 220 IQ = 1, K
         TEMP3 = IQ*(IQ+1)
         V(IQ) = 1.0D0/TEMP3
         W(IQ) = V(IQ)
  220 CONTINUE
      IVC = 0
      KGI = 0
      IF (K.EQ.1) GO TO 380
      KGI = 1
      GI(1) = W(2)
      GO TO 380
C
C     IF ORDER WAS RAISED, UPDATE DIAGONAL PART OF V(*)
C
  240 IF (K.LE.KPREV) GO TO 320
      IF (IVC.EQ.0) GO TO 260
      JV = KP1 - IV(IVC)
      IVC = IVC - 1
      GO TO 280
  260 JV = 1
      TEMP4 = K*KP1
      V(K) = 1.0D0/TEMP4
      W(K) = V(K)
      IF (K.NE.2) GO TO 280
      KGI = 1
      GI(1) = W(2)
  280 NSM2 = NS - 2
      IF (NSM2.LT.JV) GO TO 320
      DO 300 J = JV, NSM2
         I = K - J
         V(I) = V(I) - ALPHA(J+1)*V(I+1)
         W(I) = V(I)
  300 CONTINUE
      IF (I.NE.2) GO TO 320
      KGI = NS - 1
      GI(KGI) = W(2)
C
C     UPDATE V(*) AND SET W(*)
C
  320 LIMIT1 = KP1 - NS
      TEMP5 = ALPHA(NS)
      DO 340 IQ = 1, LIMIT1
         V(IQ) = V(IQ) - TEMP5*V(IQ+1)
         W(IQ) = V(IQ)
  340 CONTINUE
      G(NSP1) = W(1)
      IF (LIMIT1.EQ.1) GO TO 360
      KGI = NS
      GI(KGI) = W(2)
  360 W(LIMIT1+1) = V(LIMIT1+1)
      IF (K.GE.KOLD) GO TO 380
      IVC = IVC + 1
      IV(IVC) = LIMIT1 + 2
C
C     COMPUTE THE G(*) IN THE WORK VECTOR W(*)
C
  380 NSP2 = NS + 2
      KPREV = K
      IF (KP1.LT.NSP2) GO TO 440
      DO 420 I = NSP2, KP1
         LIMIT2 = KP2 - I
         TEMP6 = ALPHA(I-1)
         DO 400 IQ = 1, LIMIT2
            W(IQ) = W(IQ) - TEMP6*W(IQ+1)
  400    CONTINUE
         G(I) = W(1)
  420 CONTINUE
  440 CONTINUE
C       ***     END BLOCK 1     ***
C
C       ***     BEGIN BLOCK 2     ***
C     PREDICT A SOLUTION P(*), EVALUATE DERIVATIVES USING PREDICTED
C     SOLUTION, ESTIMATE LOCAL ERROR AT ORDER K AND ERRORS AT ORDERS K,
C     K-1, K-2 AS IF CONSTANT STEP SIZE WERE USED.
C                   ***
C
C     INCREMENT COUNTER ON ATTEMPTED STEPS
C
      KSTEPS = KSTEPS + 1
C
C     CHANGE PHI TO PHI STAR
C
      IF (K.LT.NSP1) GO TO 500
      DO 480 I = NSP1, K
         TEMP1 = BETA(I)
         DO 460 L = 1, NEQN
            PHI(L,I) = TEMP1*PHI(L,I)
  460    CONTINUE
  480 CONTINUE
C
C     PREDICT SOLUTION AND DIFFERENCES
C
  500 DO 520 L = 1, NEQN
         PHI(L,KP2) = PHI(L,KP1)
         PHI(L,KP1) = 0.0D0
         P(L) = 0.0D0
  520 CONTINUE
      DO 560 J = 1, K
         I = KP1 - J
         IP1 = I + 1
         TEMP2 = G(I)
         DO 540 L = 1, NEQN
            P(L) = P(L) + TEMP2*PHI(L,I)
            PHI(L,I) = PHI(L,I) + PHI(L,IP1)
  540    CONTINUE
  560 CONTINUE
      IF (NORND) GO TO 600
      DO 580 L = 1, NEQN
         TAU = H*P(L) - PHI(L,15)
         P(L) = Y(L) + TAU
         PHI(L,16) = (P(L)-Y(L)) - TAU
  580 CONTINUE
      GO TO 640
  600 DO 620 L = 1, NEQN
         P(L) = Y(L) + H*P(L)
  620 CONTINUE
  640 XOLD = X
      X = X + H
      ABSH = ABS(H)
C     CALL F(X,P,YP,RPAR,IPAR)
      IREVCM = 6
      TWANT = X
      RETURN
  660 CONTINUE
      IREVCM = 0
C
C     ESTIMATE ERRORS AT ORDERS K,K-1,K-2
C
      ERKM2 = 0.0D0
      ERKM1 = 0.0D0
      ERK = 0.0D0
      DO 740 L = 1, NEQN
         TEMP3 = 1.0D0/WT(L)
         TEMP4 = YP(L) - PHI(L,1)
         IF (KM2) 720, 700, 680
  680    ERKM2 = ERKM2 + ((PHI(L,KM1)+TEMP4)*TEMP3)**2
  700    ERKM1 = ERKM1 + ((PHI(L,K)+TEMP4)*TEMP3)**2
  720    ERK = ERK + (TEMP4*TEMP3)**2
  740 CONTINUE
      IF (KM2) 800, 780, 760
  760 ERKM2 = ABSH*SIG(KM1)*GSTR(KM2)*SQRT(ERKM2)
  780 ERKM1 = ABSH*SIG(K)*GSTR(KM1)*SQRT(ERKM1)
  800 TEMP5 = ABSH*SQRT(ERK)
      ERR = TEMP5*(G(K)-G(KP1))
      ERK = TEMP5*SIG(KP1)*GSTR(K)
      KNEW = K
C
C     TEST IF ORDER SHOULD BE LOWERED
C
      IF (KM2) 860, 840, 820
  820 IF (MAX(ERKM1,ERKM2).LE.ERK) KNEW = KM1
      GO TO 860
  840 IF (ERKM1.LE.0.5D0*ERK) KNEW = KM1
C
C     TEST IF STEP SUCCESSFUL
C
  860 IF (ERR.LE.EPS) GO TO 1060
C       ***     END BLOCK 2     ***
C
C       ***     BEGIN BLOCK 3     ***
C     THE STEP IS UNSUCCESSFUL.  RESTORE  X, PHI(*,*), PSI(*) .
C     IF THIRD CONSECUTIVE FAILURE, SET ORDER TO ONE.  IF STEP FAILS
C     MORE THAN THREE TIMES, CONSIDER AN OPTIMAL STEP SIZE.  DOUBLE
C     ERROR TOLERANCE AND RETURN IF ESTIMATED STEP SIZE IS TOO SMALL
C     FOR MACHINE PRECISION.
C                   ***
C
C     RESTORE X, PHI(*,*) AND PSI(*)
C
      NFAIL = NFAIL + 1
      TWANT = XOLD
      IREVCM = 8
      RETURN
  880 CONTINUE
      IREVCM = 0
      PHASE1 = .FALSE.
      X = XOLD
      DO 920 I = 1, K
         TEMP1 = 1.0D0/BETA(I)
         IP1 = I + 1
         DO 900 L = 1, NEQN
            PHI(L,I) = TEMP1*(PHI(L,I)-PHI(L,IP1))
  900    CONTINUE
  920 CONTINUE
      IF (K.LT.2) GO TO 960
      DO 940 I = 2, K
         PSI(I-1) = PSI(I) - H
  940 CONTINUE
C
C     ON THIRD FAILURE, SET ORDER TO ONE.  THEREAFTER, USE OPTIMAL STEP
C     SIZE
C
  960 IFAIL = IFAIL + 1
      TEMP2 = 0.5D0
      IF (IFAIL-3) 1020, 1000, 980
  980 IF (P5EPS.LT.0.25D0*ERK) TEMP2 = SQRT(P5EPS/ERK)
 1000 KNEW = 1
 1020 H = TEMP2*H
      K = KNEW
      NS = 0
      IF (ABS(H).GE.FOURU*ABS(X)) GO TO 1040
      CRASH = .TRUE.
      H = SIGN(FOURU*ABS(X),H)
      EPS = EPS + EPS
      RETURN
 1040 GO TO 160
C       ***     END BLOCK 3     ***
C
C       ***     BEGIN BLOCK 4     ***
C     THE STEP IS SUCCESSFUL.  CORRECT THE PREDICTED SOLUTION, EVALUATE
C     THE DERIVATIVES USING THE CORRECTED SOLUTION AND UPDATE THE
C     DIFFERENCES.  DETERMINE BEST ORDER AND STEP SIZE FOR NEXT STEP.
C                   ***
 1060 KOLD = K
      HOLD = H
      NSUCC = NSUCC + 1
C
C     CORRECT AND EVALUATE
C
      TEMP1 = H*G(KP1)
      IF (NORND) GO TO 1100
      DO 1080 L = 1, NEQN
         TEMP3 = Y(L)
         RHO = TEMP1*(YP(L)-PHI(L,1)) - PHI(L,16)
         Y(L) = P(L) + RHO
         PHI(L,15) = (Y(L)-P(L)) - RHO
         P(L) = TEMP3
 1080 CONTINUE
      GO TO 1140
 1100 DO 1120 L = 1, NEQN
         TEMP3 = Y(L)
         Y(L) = P(L) + TEMP1*(YP(L)-PHI(L,1))
         P(L) = TEMP3
 1120 CONTINUE
C     420  CALL F(X,Y,YP,RPAR,IPAR)
 1140 IREVCM = 7
      TWANT = X
      RETURN
 1160 CONTINUE
      IREVCM = 0
C
C     UPDATE DIFFERENCES FOR NEXT STEP
C
      DO 1180 L = 1, NEQN
         PHI(L,KP1) = YP(L) - PHI(L,1)
         PHI(L,KP2) = PHI(L,KP1) - PHI(L,KP2)
 1180 CONTINUE
      DO 1220 I = 1, K
         DO 1200 L = 1, NEQN
            PHI(L,I) = PHI(L,I) + PHI(L,KP1)
 1200    CONTINUE
 1220 CONTINUE
C
C     ESTIMATE ERROR AT ORDER K+1 UNLESS:
C     IN FIRST PHASE WHEN ALWAYS RAISE ORDER,
C     ALREADY DECIDED TO LOWER ORDER,
C     STEP SIZE NOT CONSTANT SO ESTIMATE UNRELIABLE
C
      ERKP1 = 0.0D0
      IF (KNEW.EQ.KM1 .OR. K.EQ.12) PHASE1 = .FALSE.
      IF (PHASE1) GO TO 1280
      IF (KNEW.EQ.KM1) GO TO 1300
      IF (KP1.GT.NS) GO TO 1320
      DO 1240 L = 1, NEQN
         ERKP1 = ERKP1 + (PHI(L,KP2)/WT(L))**2
 1240 CONTINUE
      ERKP1 = ABSH*GSTR(KP1)*SQRT(ERKP1)
C
C     USING ESTIMATED ERROR AT ORDER K+1, DETERMINE APPROPRIATE ORDER
C     FOR NEXT STEP
C
      IF (K.GT.1) GO TO 1260
      IF (ERKP1.GE.0.5D0*ERK) GO TO 1320
      GO TO 1280
 1260 IF (ERKM1.LE.MIN(ERK,ERKP1)) GO TO 1300
      IF (ERKP1.GE.ERK .OR. K.EQ.12) GO TO 1320
C
C     HERE ERKP1 .LT. ERK .LT. AMAX1(ERKM1,ERKM2) ELSE ORDER WOULD HAVE
C     BEEN LOWERED IN BLOCK 2.  THUS ORDER IS TO BE RAISED
C
C     RAISE ORDER
C
 1280 K = KP1
      ERK = ERKP1
      GO TO 1320
C
C     LOWER ORDER
C
 1300 K = KM1
      ERK = ERKM1
C
C     WITH NEW ORDER DETERMINE APPROPRIATE STEP SIZE FOR NEXT STEP
C
 1320 HNEW = H + H
      IF (PHASE1) GO TO 1340
      IF (P5EPS.GE.ERK*TWO(K+1)) GO TO 1340
      HNEW = H
      IF (P5EPS.GE.ERK) GO TO 1340
      TEMP2 = K + 1
      R = (P5EPS/ERK)**(1.0D0/TEMP2)
      HNEW = ABSH*MAX(0.5D0,MIN(0.9D0,R))
      HNEW = SIGN(MAX(HNEW,FOURU*ABS(X)),H)
 1340 H = HNEW
      RETURN
C       ***     END BLOCK 4     ***
C
C
C     END OF D02QFQ (STEPS)
C
C
      END
      SUBROUTINE D02QFR(X,Y,XOUT,YOUT,YPOUT,NINT,NEQN,KOLD,PHI,IVC,IV,
     *                  KGI,GI,ALPHA,OG,OW,OX,OY)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C
C     MODIFIED TO INTERPOLATE FIRST NINT COMPONENTS
C                             ----------
C
C
C     PURPOSE
C     =======
C            APPROXIMATES THE SOLUTION AT XOUT BY EVALUATING THE
C            POLYNOMIAL COMPUTED IN D02QFQ AT XOUT.  MUST BE USED IN
C            CONJUNCTION WITH D02QFQ.
C     DESCRIPTION
C     ===========
C
C     WRITTEN BY L. F. SHAMPINE AND M. K. GORDON
C
C     ABSTRACT
C
C
C     THE METHODS IN SUBROUTINE D02QFQ  APPROXIMATE THE SOLUTION NEAR  X
C     BY A POLYNOMIAL.  SUBROUTINE  D02QFR  APPROXIMATES THE SOLUTION AT
C     XOUT BY EVALUATING THE POLYNOMIAL THERE. INFORMATION DEFINING THIS
C     POLYNOMIAL IS PASSED FROM D02QFQ  SO D02QFR  CANNOT BE USED ALONE.
C
C     THIS CODE IS COMPLETELY EXPLAINED AND DOCUMENTED IN THE TEXT,
C     COMPUTER SOLUTION OF ORDINARY DIFFERENTIAL EQUATIONS, THE INITIAL
C     VALUE PROBLEM  BY L. F. SHAMPINE AND M. K. GORDON.
C     FURTHER DETAILS ON USE OF THIS CODE ARE AVAILABLE IN *SOLVING
C     ORDINARY DIFFERENTIAL EQUATIONS WITH ODE, STEP, AND INTRP*,
C     BY L. F. SHAMPINE AND M. K. GORDON, SLA-73-1060.
C
C     INPUT TO D02QFR --
C
C     THE USER PROVIDES STORAGE IN THE CALLING PROGRAM FOR THE ARRAYS IN
C     THE CALL LIST
C      DIMENSION Y(NEQN),YOUT(NEQN),YPOUT(NEQN),PHI(NEQN,16),OY(NEQN)
C                AND ALPHA(12),OG(13),OW(12),GI(11),IV(10)
C     AND DEFINES
C      XOUT -- POINT AT WHICH SOLUTION IS DESIRED.
C     THE REMAINING PARAMETERS ARE DEFINED IN  D02QFQ  AND PASSED TO
C     D02QFR  FROM THAT SUBROUTINE
C
C     OUTPUT FROM  D02QFR  --
C
C      YOUT(*) -- SOLUTION AT  XOUT
C      YPOUT(*) -- DERIVATIVE OF SOLUTION AT  XOUT
C
C     THE REMAINING PARAMETERS ARE RETURNED UNALTERED FROM THEIR INPUT
C     VALUES.  INTEGRATION WITH  D02QFQ  MAY BE CONTINUED.
C
C     REFERENCES
C     ==========
C               SHAMPINE L.F., GORDON M.K., *SOLVING ORDINARY
C                 DIFFERENTIAL EQUATIONS WITH ODE, STEP, AND INTRP*,
C                 SLA-73-1060, SANDIA LABORATORIES, 1973.
C               WATTS H.A., SHAMPINE L.F., *A SMOOTHER INTERPOLANT FOR
C                 DE/STEP,INTRP : II*, SAND84-0293, SANDIA LABORATORIES,
C                 1984.
C
C     DATE WRITTEN   740101   (YYMMDD)
C     REVISION DATE  840201   (YYMMDD)
C     AUTHOR  SHAMPINE, L.F.,  SNLA
C           GORDON, M.K.
C             MODIFIED BY H.A. WATTS
C
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  OX, X, XOUT
      INTEGER           IVC, KGI, KOLD, NEQN, NINT
C     .. Array Arguments ..
      DOUBLE PRECISION  ALPHA(12), GI(11), OG(13), OW(12), OY(NEQN),
     *                  PHI(NEQN,16), Y(NEQN), YOUT(NINT), YPOUT(NINT)
      INTEGER           IV(10)
C     .. Local Scalars ..
      DOUBLE PRECISION  ALP, GAMMA, GDI, GDIF, H, HI, HMU, RMU, SIGMA,
     *                  TEMP1, TEMP2, TEMP3, XI, XIM1, XIQ
      INTEGER           I, IQ, IW, J, JQ, KP1, KP2, L, M
C     .. Local Arrays ..
      DOUBLE PRECISION  C(13), G(13), W(13)
C     .. Executable Statements ..
C
      KP1 = KOLD + 1
      KP2 = KOLD + 2
C
      HI = XOUT - OX
      H = X - OX
      XI = HI/H
      XIM1 = XI - 1.D0
C
C     INITIALIZE W(*) FOR COMPUTING G(*)
C
      XIQ = XI
      DO 20 IQ = 1, KP1
         XIQ = XI*XIQ
         TEMP1 = IQ*(IQ+1)
         W(IQ) = XIQ/TEMP1
   20 CONTINUE
C
C     COMPUTE THE DOUBLE INTEGRAL TERM GDI
C
      IF (KOLD.LE.KGI) GO TO 100
      IF (IVC.GT.0) GO TO 40
      GDI = 1.0D0/TEMP1
      M = 2
      GO TO 60
   40 IW = IV(IVC)
      GDI = OW(IW)
      M = KOLD - IW + 3
   60 IF (M.GT.KOLD) GO TO 120
      DO 80 I = M, KOLD
         GDI = OW(KP2-I) - ALPHA(I)*GDI
   80 CONTINUE
      GO TO 120
  100 GDI = GI(KOLD)
C
C     COMPUTE G(*) AND C(*)
C
  120 G(1) = XI
      G(2) = 0.5D0*XI*XI
      C(1) = 1.0D0
      C(2) = XI
      IF (KOLD.LT.2) GO TO 180
      DO 160 I = 2, KOLD
         ALP = ALPHA(I)
         GAMMA = 1.0D0 + XIM1*ALP
         L = KP2 - I
         DO 140 JQ = 1, L
            W(JQ) = GAMMA*W(JQ) - ALP*W(JQ+1)
  140    CONTINUE
         G(I+1) = W(1)
         C(I+1) = GAMMA*C(I)
  160 CONTINUE
C
C     DEFINE INTERPOLATION PARAMETERS
C
  180 SIGMA = (W(2)-XIM1*W(1))/GDI
      RMU = XIM1*C(KP1)/GDI
      HMU = RMU/H
C
C     INTERPOLATE FOR THE SOLUTION -- YOUT
C     AND FOR THE DERIVATIVE OF THE SOLUTION -- YPOUT
C
C     DO 200 L = 1, NEQN
      DO 200 L = 1, NINT
         YOUT(L) = 0.0D0
         YPOUT(L) = 0.0D0
  200 CONTINUE
      DO 240 J = 1, KOLD
         I = KP2 - J
         GDIF = OG(I) - OG(I-1)
         TEMP2 = (G(I)-G(I-1)) - SIGMA*GDIF
         TEMP3 = (C(I)-C(I-1)) + RMU*GDIF
C        DO 220 L = 1, NEQN
         DO 220 L = 1, NINT
            YOUT(L) = YOUT(L) + TEMP2*PHI(L,I)
            YPOUT(L) = YPOUT(L) + TEMP3*PHI(L,I)
  220    CONTINUE
  240 CONTINUE
C     DO 260 L = 1, NEQN
      DO 260 L = 1, NINT
         YOUT(L) = ((1.0D0-SIGMA)*OY(L)+SIGMA*Y(L)) + H*(YOUT(L)+(G(1)
     *             -SIGMA*OG(1))*PHI(L,1))
         YPOUT(L) = HMU*(OY(L)-Y(L)) + (YPOUT(L)+(C(1)+RMU*OG(1))*PHI(L,
     *              1))
  260 CONTINUE
C
      RETURN
C
C
C     END OF D02QFR (SINTRP)
C
C
      END
      SUBROUTINE D02QFS(T,YINT,YPINT,NEQ,X,YY,P,PHI)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C
C     D02QFS DOES THE INTERPOLATION FOR THE ROOT FINDING TASK IN
C     D02QFF/D02QGF.
C     IT DEFINES THE GENERIC ROUTINE RINTRP CALLED BY SUBROUTINE D02QFV.
C     BECAUSE OF DIFFERENT INTERPOLATION SCHEMES WITH EACH OF THE
C     INTEGRATION METHODS, THE VARIOUS REPRESENTATIVES FOR RINTRP MUST
C     NECESSARILY BE DIFFERENT.
C
C
C     DATE WRITTEN   840908   (YYMMDD)
C     REVSION DATE   850101   (YYMMDD)
C     AUTHOR WATTS, H. A., (SNLA)
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  T, X
      INTEGER           NEQ
C     .. Array Arguments ..
      DOUBLE PRECISION  P(NEQ), PHI(NEQ,*), YINT(NEQ), YPINT(NEQ),
     *                  YY(NEQ)
C     .. Scalars in Common ..
      DOUBLE PRECISION  HOLD, TOLD, TSTAR, TWOU, XOLD, XSAVE
      INTEGER           IBEGIN, IINTEG, INFLOP, INIT, IQUIT, ITOL,
     *                  ITSTOP, IVC, KGI, KLE4, KOLD, KORD, KPREV,
     *                  KSTEPS, NS
      LOGICAL           INTOUT, NORND, PHASE1, START, STIFF
C     .. Arrays in Common ..
      DOUBLE PRECISION  ALPHA(12), BETA(12), G(13), GI(11), PSI(12),
     *                  SIG(13), V(12), W(12)
      INTEGER           IV(10)
C     .. External Subroutines ..
      EXTERNAL          D02QFR
C     .. Common blocks ..
      COMMON            /AD02QF/ALPHA, BETA, PSI, V, W, SIG, G, GI,
     *                  XOLD, HOLD, TOLD, XSAVE, TSTAR, TWOU, INIT,
     *                  IBEGIN, ITOL, IINTEG, ITSTOP, INFLOP, IQUIT, IV,
     *                  NS, KORD, KOLD, KSTEPS, KLE4, KPREV, IVC, KGI,
     *                  START, PHASE1, NORND, STIFF, INTOUT
C     .. Save statement ..
      SAVE              /AD02QF/
C     .. Executable Statements ..
C
C     CALL SINTRP(X,YY,T,YINT,YPINT,NEQ,NEQ,KOLD,PHI,IVC,IV,KGI,GI,
C                 ALPHA,G,W,XOLD,P)
      CALL D02QFR(X,YY,T,YINT,YPINT,NEQ,NEQ,KOLD,PHI,IVC,IV,KGI,GI,
     *            ALPHA,G,W,XOLD,P)
C     CALL SINTRP(X,YY,T,YINT,YPINT,NEQ,KOLD,PHI,IVC,IV,KGI,GI,ALPHA,G,
C                 W,XOLD,P)
C
      RETURN
C
C
C     END OF D02QFS (RINTAM)
C
C
      END
      SUBROUTINE D02QFT(A,FA,B,FB,REZ,AEZ,IFLAG)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C
C     PURPOSE
C     =======
C     D02QFT SEARCHES FOR A ZERO OF A FUNCTION F(X) BETWEEN
C     THE GIVEN VALUES A AND B UNTIL THE WIDTH OF THE INTERVAL
C     (A,B) HAS COLLAPSED TO WITHIN A TOLERANCE SPECIFIED BY
C     THE STOPPING CRITERION, ABS(A-B) .LE. 2.*(REZ*ABS(B)+AEZ).
C
C     DESCRIPTION
C     ===========
C     D02QFT IS A MODIFICATION OF THE CODE ZEROIN WHICH WAS BASED ON A
C     METHOD BY T.J. DEKKER AND WRITTEN BY L.F. SHAMPINE AND H.A. WATTS.
C     THE METHOD USED IS AN EFFICIENT COMBINATION OF BISECTION AND THE
C     SECANT RULE.  THIS ROUTINE WAS DESIGNED TO BE USED IN CONJUNCTION
C     WITH AN ODE SOLVER FROM DEPAC, UTILIZING THE TECHNIQUE OF REVERSE
C     COMMUNICATION.
C
C     DESCRIPTION OF ARGUMENTS
C
C     A,FA,B,FB,REZ,AEZ, AND IFLAG ARE INPUT PARAMETERS
C
C     A,B AND IFLAG ARE OUTPUT PARAMETERS
C
C     C,FC,D,FD,FM,FX,FPREV,FMIN,FMAX,FAVG,AMB,AMBS,SBMA,SF,DEZU34,
C     IC,KMC,ISING,LOCEXT,KTEST, AND KOUNT ARE VALUES NEEDED INTERNALLY
C     IN THE COMPUTATION.
C
C     * A,B     - ENDS OF THE INTERVAL (A,B).  ON INPUT, IT IS ASSUMED
C                 THAT INTEGRATION PROCEEDS IN THE DIRECTION FROM A TO
C                 B.  ON OUTPUT, B IS EXPECTED TO BE USED FOR THE
C                 COMPUTED ZERO OF F IN AN APPROPRIATE ODE ROOT SOLVING
C                 ROUTINE.  IN PARTICULAR, THE SIGN OF B-A WILL BE
C                 PRESERVED FROM INPUT TO OUTPUT.  THE CONSEQUENCE OF
C                 THIS IS THAT B MAY NOT CORRESPOND TO THE POINT HAVING
C                 THE SMALLEST RESIDUAL.
C
C     FA,FB     - VALUES OF F(A) AND F(B).  ON INPUT (IFLAG=0) BOTH F(A)
C                 AND F(B) MUST BE PROVIDED.  ON SUBSEQUENT CALLS (WHEN
C                 IFLAG = -1) F(B) MUST BE EVALUATED AND PROVIDED.
C
C     REZ,AEZ   - RELATIVE AND ABSOLUTE ERRORS USED IN THE STOPPING
C                 CRITERION.
C
C     * IFLAG   - A STATUS CODE.  USER MUST CHECK IFLAG AFTER EACH CALL.
C                 CONTROL RETURNS TO THE USER FROM D02QFT IN ALL CASES.
C
C                 0 INDICATES INITIALIZATION OF THE ROUTINE.  THE
C                   BRACKETING INTERVAL (A,B) MUST BE PROVIDED ALONG
C                   WITH THE VALUES F(A) AND F(B).  IT IS TACITLY
C                   ASSUMED THAT  F(A)*F(B) .LE. 0.  ERROR TOLERANCES
C                   REZ AND AEZ MUST BE PROVIDED.
C
C                -1 INDICATES THAT A FUNCTION EVALUATION F(B) IS NEEDED.
C                   SET FB=F(B) AND CALL THE CODE AGAIN WITHOUT CHANGING
C                   IFLAG.
C
C                 1 B IS WITHIN THE REQUESTED TOLERANCE OF A ZERO.
C                   THE INTERVAL (A,B) COLLAPSED TO THE REQUESTED
C                   TOLERANCE, THE FUNCTION CHANGES SIGN IN (A,B),
C                   AND F(X) DECREASED IN MAGNITUDE AS (A,B) COLLAPSED.
C
C                 2 F(B) = 0.  HOWEVER, THE INTERVAL (A,B) MAY NOT HAVE
C                   COLLAPSED TO THE REQUESTED TOLERANCE.
C
C                 3 NO CHANGE IN SIGN OF F(X) WAS FOUND ALTHOUGH THE
C                   INTERVAL (A,B) COLLAPSED TO THE REQUESTED TOLERANCE.
C                   BECAUSE F(X) CONTINUALLY DECREASED IN MAGNITUDE, B
C                   APPEARS TO BE NEAR TO A ZERO OF EVEN MULTIPLICITY.
C                   REDUCING THE TOLERANCE WILL HELP CLARIFY THE ISSUE.
C
C                 4 NO CHANGE IN SIGN OF F(X) WAS FOUND.  ALSO, THE
C                   INTERVAL (A,B) MAY NOT HAVE COLLAPSED TO THE
C                   REQUESTED TOLERANCE.  IT APPEARS THAT A LOCAL
C                   EXTREMAL POINT OF F(X) IS BEING ISOLATED.  THE USER
C                   MUST EXAMINE THIS CASE AND DECIDE WHETHER B IS NEAR
C                   LOCAL EXTREMA OF F(X), OR B IS NEAR A ZERO OF EVEN
C                   MULTIPLICITY.
C
C                 5 B MAY BE NEAR A SINGULAR POINT OF F(X).
C                   THE FUNCTION CHANGES SIGN IN (A,B) BUT THE INTERVAL
C                   MAY NOT HAVE COLLAPSED TO THE REQUESTED TOLERANCE.
C                   F(X) INCREASED IN MAGNITUDE AS (A,B) COLLAPSED.
C
C                 6 TOO MANY (.GT. 500) FUNCTION EVALUATIONS WERE USED.
C
C     REFERENCES
C     ==========
C               SHAMPINE L.F., WATTS H.A., *ZEROIN, A ROOT-SOLVING
C                 CODE*, SC-TM-70-631, SANDIA LABORATORIES, 1970.
C               DEKKER T.J., FINDING A ZERO BY MEANS OF SUCCESSIVE
C                 LINEAR INTERPOLATION, *CONSTRUCTIVE ASPECTS OF THE
C                 FUNDAMENTAL THEOREM OF ALGEBRA*, EDITED BY B DEJON
C                 AND P HENRICI, 1969.
C
C     DATE WRITTEN   820701   (YYMMDD)
C     REVISION DATE  840427   (YYMMDD)
C     AUTHOR  WATTS, H. A., (SNLA)
C
C
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  A, AEZ, B, FA, FB, REZ
      INTEGER           IFLAG
C     .. Scalars in Common ..
      DOUBLE PRECISION  AMB, AMBS, C, D, DEZU34, FAVG, FC, FD, FM, FMAX,
     *                  FMIN, FPREV, FX, SBMA, SF
      INTEGER           IC, ISING, KMC, KOUNT, KTEST
      LOGICAL           LOCEXT
C     .. Local Scalars ..
      DOUBLE PRECISION  AAMB, FTEST, P, Q, TOL
      LOGICAL           ABC, SIGNC
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, SIGN
C     .. Common blocks ..
      COMMON            /DD02QF/C, FC, D, FD, FM, FX, FPREV, FMIN, FMAX,
     *                  FAVG, AMB, AMBS, SBMA, SF, DEZU34, IC, KMC,
     *                  ISING, KOUNT, KTEST, LOCEXT
C     .. Save statement ..
      SAVE              /DD02QF/
C     .. Executable Statements ..
C
      IF (IFLAG.LT.0) GO TO 20
C
C     INITIALIZE
C
      IC = 0
      AMBS = ABS(A-B)
      SF = AMBS/MAX(ABS(A),ABS(B))
      SBMA = SIGN(1.0D0,B-A)
      ABC = .TRUE.
      C = A
      FC = FA
      KOUNT = 0
      KTEST = 0
      FX = MAX(ABS(FA),ABS(FB))
      D = B
      FD = FB
      KMC = 0
      FM = MIN(ABS(FA),ABS(FB))
      FPREV = FX
      FMIN = FM
      FMAX = FM
      FAVG = 0.D0
      ISING = 0
      LOCEXT = .FALSE.
      SIGNC = .TRUE.
      IF (SIGN(1.D0,FA).EQ.SIGN(1.D0,FB)) SIGNC = .FALSE.
      GO TO 180
C
C     SET UP TESTS FOR SINGULARITY AND LOCAL MINIMUM
C
   20 FTEST = ABS(FB)
      FAVG = FAVG + FTEST
      IF (KOUNT.LT.KTEST+5) GO TO 40
      KTEST = KOUNT
      FAVG = FAVG/5.D0
      ISING = ISING + 1
      IF (FAVG.LE.2.0D0*FMAX) ISING = 0
      IF (ISING.EQ.5) GO TO 440
      FMAX = MAX(FMAX,FAVG)
      LOCEXT = .TRUE.
      IF (FAVG.LE.0.5D0*FMIN) LOCEXT = .FALSE.
      FMIN = MIN(FMIN,FAVG)
      FAVG = 0.D0
C
C     DECIDE WHETHER NEXT STEP IS INTERPOLATION OR EXTRAPOLATION
C
   40 IF (SIGN(1.0D0,FB).EQ.SIGN(1.0D0,FA)) GO TO 60
      SIGNC = .TRUE.
      D = B
      GO TO 180
   60 IF (SIGN(1.0D0,FC).EQ.SIGN(1.0D0,FA)) GO TO 80
      A = C
      FA = FC
      SIGNC = .TRUE.
      D = B
      GO TO 180
C
C     USE DIFFERENT STRATEGY WHEN NO CHANGE IN SIGN IS FOUND
C
   80 SIGNC = .FALSE.
      IF (ABS(FB).GT.ABS(FC)) GO TO 120
      IF (SIGN(1.D0,B-A).EQ.SIGN(1.D0,B-C)) GO TO 100
      ABC = .TRUE.
      D = C
      FD = FC
      GO TO 160
  100 ABC = .FALSE.
      A = C
      FA = FC
      GO TO 160
  120 IF (SIGN(1.D0,B-A).EQ.SIGN(1.D0,B-C)) GO TO 140
      A = B
      FA = FB
      B = C
      FB = FC
      C = A
      FC = FA
      ABC = .FALSE.
      GO TO 160
  140 D = B
      FD = FB
      B = C
      FB = FC
      C = D
      FC = FD
      ABC = .TRUE.
  160 IF (ABS(AMB).LE.DEZU34*ABS(B)) GO TO 180
      KMC = KMC + 1
      IF (FTEST.LT.0.99D0*FPREV) KMC = 0
      IF (KMC.EQ.4) GO TO 420
      FPREV = FTEST
C
  180 IF (ABS(FA).GE.ABS(FB)) GO TO 200
C
C     PERFORM INTERCHANGE SO THAT F(B) IS ASSOCIATED WITH THE
C     MINIMUM VALUE.
C
      C = B
      FC = FB
      B = A
      FB = FA
      A = C
      FA = FC
      D = B
      FD = FB
C
  200 AMB = 0.5D0*(A-D)
      AAMB = ABS(AMB)
      TOL = REZ*ABS(B) + AEZ
C
C      TEST STOPPING CRITERION AND FUNCTION COUNT
C
      IF (AAMB.LE.TOL) GO TO 360
      IF (FB.EQ.0.D0) GO TO 380
      IF (KOUNT.GE.500) GO TO 460
C
C     IF NO SIGN CHANGE, BISECT APPROPRIATE SUBINTERVAL
C
      IF (SIGNC) GO TO 220
      C = B
      FC = FB
      IF (ABC .OR. B.EQ.D) GO TO 320
      B = B + 0.5D0*(D-B)
      GO TO 340
C
C     CALCULATE NEW ITERATE IMPLICITLY AS B+P/Q
C     WHERE WE ARRANGE P .GE. 0.
C     THE IMPLICIT FORM IS USED TO PREVENT OVERFLOW.
C
  220 P = (B-C)*FB
      Q = FC - FB
      IF (P.GE.0.D0) GO TO 240
      P = -P
      Q = -Q
C
C     UPDATE C AND CHECK FOR SATISFACTORY REDUCTION
C     IN THE SIZE OF THE BRACKETING INTERVAL.  IF NOT,
C     PERFORM BISECTION.
C
  240 C = B
      FC = FB
      IC = IC + 1
      IF (IC.LT.4) GO TO 260
      IF (8.D0*AAMB.GE.AMBS) GO TO 320
      IC = 0
      AMBS = AAMB
C
C     TEST FOR TOO SMALL A CHANGE
C
  260 IF (P.GT.ABS(Q)*TOL) GO TO 280
C
C     INCREMENT BY TOLERANCE
C
      B = B + SIGN(TOL,AMB)
      GO TO 340
C
C     ROOT OUGHT TO BE BETWEEN B AND (A+B)/2.
C
  280 IF (P.GE.AMB*Q) GO TO 300
C
C     USE SECANT RULE
C
      B = B + P/Q
      GO TO 340
C
C     SECANT RULE UNACCEPTABLE
C
  300 IF (1.D+3*ABS(FB).GT.ABS(FA)) GO TO 320
C
C     INCREMENT B BY A REASONABLE AMOUNT
C
      B = B + SIGN(MAX(0.01D0*AAMB,TOL),AMB)
      GO TO 340
C
C     USE BISECTION
C
  320 B = B + 0.5D0*(A-B)
C
C     HAVE COMPLETED COMPUTATION FOR NEW ITERATE B.
C     NOW RETURN TO CALLING PROGRAM FOR EVALUATION
C     OF F(B).
C
  340 IFLAG = -1
      KOUNT = KOUNT + 1
      RETURN
C
C     FINISHED. PROCESS RESULTS FOR PROPER SETTING OF IFLAG
C
  360 IF ( .NOT. SIGNC) GO TO 400
      IF (ABS(FB).GT.FX) GO TO 440
      IFLAG = 1
      IF (SIGN(1.0D0,B-A).EQ.SBMA) RETURN
      C = B
      FC = FB
      B = A
      FB = FA
      A = C
      FA = FC
      RETURN
  380 IFLAG = 2
      RETURN
  400 SF = MAX(1.D+10*MIN(2.D0*SF,1.D0),10.D0)
      IF (SF*ABS(FB).GT.FM .OR. LOCEXT) GO TO 420
      IFLAG = 3
      RETURN
  420 IFLAG = 4
      RETURN
  440 IFLAG = 5
      RETURN
  460 IFLAG = 6
      RETURN
C
C
C     END OF D02QFT (DEZERO)
C
C
      END
      SUBROUTINE D02QFU(IREVCM,K,GWANT,NEQG,KROOT,INROOT,GOLD,PROOT,
     *                  ROOTD,GP,IGSC,TOUT)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C
C     DATE WRITTEN   840908   (YYMMDD)
C     REVISION DATE  850101   (YYMMDD)
C     AUTHOR  WATTS, H. A., (SNLA)
C
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  GWANT, TOUT
      INTEGER           INROOT, IREVCM, K, KROOT, NEQG
C     .. Array Arguments ..
      DOUBLE PRECISION  GOLD(NEQG), GP(NEQG), PROOT(NEQG), ROOTD(NEQG)
      INTEGER           IGSC(NEQG)
C     .. Scalars in Common ..
      DOUBLE PRECISION  DELSGN, FOURU, SRBIG, SRU, SVTNEW, TLEFT,
     *                  TROOTS, U, U34, U78, ZERO
      INTEGER           INROTP, KROO, KROOTP
      LOGICAL           DISCOP, GSTOP, NEEDG, NEWGEQ, PGSTOP, PSERCH,
     *                  ROOT, ROOTS, SEARCH
C     .. Local Scalars ..
      DOUBLE PRECISION  GTST
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, SIGN
C     .. Common blocks ..
      COMMON            /BD02QF/ZERO, U, FOURU, SRU, U34, U78, SRBIG,
     *                  DELSGN, TROOTS, TLEFT, SVTNEW, KROOTP, INROTP,
     *                  GSTOP, PGSTOP, ROOT, ROOTS, NEEDG, DISCOP,
     *                  NEWGEQ, SEARCH, PSERCH
      COMMON            /HD02QF/KROO
C     .. Save statement ..
      SAVE              /BD02QF/, /HD02QF/
C     .. Executable Statements ..
C
C     -- IT IS PRESUMED THAT THE USER HAS TOLD THE CODE THAT INTEGRATION
C        CANNOT BE CARRIED OUT BEYOND SOME POINT TSTOP. SECONDLY, IN
C        STEPPING TO TSTOP, IT IS PRESUMED THAT THE INTERVAL IS TOO
C        SMALL TO USE THE BASIC INTEGRATION METHOD OVER. INSTEAD, AN
C        EXTRAPOLATION OF THE SOLUTION IS ASSUMED BY SOME MEANS, SUCH AS
C        USING THE EULER FORMULA. IN THESE SPECIAL CIRCUMSTANCES, THIS
C        ROUTINE CAN BE CALLED TO CHECK FOR A ROOT ON THIS EXTREMELY
C        TINY INTERVAL.
C
      IF (IREVCM.EQ.12) GO TO 20
      K = 1
      IREVCM = 12
      RETURN
   20 CONTINUE
C     DO 20 K=1,NEQG
C       GTST = GRF(TOUT,Y,YPOUT,K,RPAR,IPAR)
      GTST = GWANT
      IF (ABS(GTST).GT.ZERO) GO TO 40
      IF (ABS(IGSC(K)).NE.1) IGSC(K) = 2
      GO TO 60
   40 IF (SIGN(1.D0,GOLD(K)).EQ.SIGN(1.D0,GTST)) GO TO 100
      IGSC(K) = 1
      IF (GTST.LT.0.D0) IGSC(K) = -1
   60 ROOT = .TRUE.
      KROO = K
      GOLD(K) = GTST
      GP(K) = GTST
      IF ( .NOT. SEARCH) GO TO 80
      IF (PROOT(K).NE.SRBIG) ROOTD(K) = ABS(PROOT(K)-TOUT)
   80 PROOT(K) = TOUT
C     20 CONTINUE
  100 K = K + 1
      IF (K.LE.NEQG) RETURN
      IREVCM = 0
      IF ( .NOT. ROOT) RETURN
      ROOTS = .TRUE.
      TROOTS = TOUT
      KROOTP = KROOT
      KROOT = KROO
      INROTP = INROOT
      INROOT = 1
      RETURN
C
C
C     END OF D02QFU (RDEO)
C
C
      END
      SUBROUTINE D02QFV(IREVCM,TWANT,KWANT,GWANT,NEQ,T,Y,YPOUT,TOUT,X,
     *                  YY,R,R2D,RINTRP,NEQG,GOLD,GNEW,GP,TGV,GV,TKT,
     *                  TLBMR,TRBMR,PROOT,ROOTD,MMREQ,INDXG,IGSC,NEEDGK,
     *                  KROOT,INROOT,IZFLAG)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     MARK 15B REVISED. IER-947 (NOV 1991).
C
C
C     D02QFV CONSTITUTES THE ROOT SEARCHING ALGORITHM WHICH IS PERFORMED
C     ON EACH INTEGRATION STEP (FOR ODE CODES WITH ROOT FINDING
C     CAPABILITIES)
C
C
C     DATE WRITTEN   840908   (YYMMDD)
C     REVISION DATE  850101   (YYMMDD)
C     AUTHOR  WATTS, H. A., (SNLA)
C
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  GWANT, T, TOUT, TWANT, X
      INTEGER           INROOT, IREVCM, IZFLAG, KROOT, KWANT, NEQ, NEQG
C     .. Array Arguments ..
      DOUBLE PRECISION  GNEW(NEQG), GOLD(NEQG), GP(NEQG), GV(NEQG,3),
     *                  PROOT(NEQG), R(NEQ), R2D(NEQ,*), ROOTD(NEQG),
     *                  TGV(NEQG,3), TKT(NEQG), TLBMR(NEQG),
     *                  TRBMR(NEQG), Y(NEQ), YPOUT(NEQ), YY(NEQ)
      INTEGER           IGSC(NEQG), INDXG(NEQG), MMREQ(NEQG),
     *                  NEEDGK(NEQG)
C     .. Subroutine Arguments ..
      EXTERNAL          RINTRP
C     .. Scalars in Common ..
      DOUBLE PRECISION  AEZ, AGTRL, AMB, AMBS, AT, ATM, ATMTR, BRD,
     *                  BRDS, DDT, DELSGN, DELTG, DELTGM, DELTR, DEZU34,
     *                  DG, DTG, DTGK, DTGP, DTQR, FAC, FOURU, G21, G32,
     *                  GAT, GAVG, GBR, GBRC, GBRMIN, GBRMNS, GCT,
     *                  GLOCMX, GM, GMAX, GMIN, GMSIGN, GMX, GOLDSV,
     *                  GOT, GPREV, GRES, GRIGHT, GT21, GT32, GTD,
     *                  GTINT, GTQR, GTRL, GTS, GTT, GTTMR, GVALUE,
     *                  GVDIF, GVMAX, GVMIN, OMU78, OPU78, PU, QC0, QC1,
     *                  QC2, QD, QDQ, QR1, QR1N, QR1P, QUADMN, RD, RDG,
     *                  REM, REMD, REZ, ROOTNO, SBMA, SDG, SF, SIGNG,
     *                  SLOPE1, SLOPE2, SLOPEP, SOTGV, SRBIG, SRU, SS,
     *                  SSTU78, SVTNEW, T21, T31, T32, TADDON, TCB, TCF,
     *                  TCLOSE, TD, TDIF, TDMN, TDMX, TFAR, TGBRMN,
     *                  TGVDIF, TGVMT, TINT, TINTP, TK, TKOLD, TLBK,
     *                  TLEFT, TNEW, TP, TPOINT, TPREV, TQR, TQR1, TQR2,
     *                  TQRF, TQRMP, TQRP, TQS, TQT, TRD, TRJ, TRL, TRN,
     *                  TRNOW, TROOT, TROOTS, TS, TSAVE, TSLOP, TSRU,
     *                  TSTEP, TT, TU78, TUT, TZ, TZERO, TZEROK, TZJ,
     *                  TZK, U, U34, U78, ZERO, GRNO, GT, STTU78
      INTEGER           I, I1, I2, I21, I3, IADD, IC, IC1, IC2, ICASE,
     *                  ICBR, ICBRK, IDTG, IGA, IJK, IK, IKMR, IKTQR,
     *                  INDX, INROTP, IPATH, ISI, ISIN, ISING, ISR,
     *                  ITGVT, ITRY, J, J1, J2, J23, J3, JP1, JR, JSR,
     *                  K, KGE, KMC, KOUNT, KP1, KROOTN, KROOTO, KROOTP,
     *                  KROOTS, KSKPMT, KTEST, KTRY, L, LTQBIG, LTR,
     *                  MMR, MMRIN, MMRK, NSR, NTIN, NTINM
      LOGICAL           BACKR, DISCOP, GSTOP, LOCEXT, MROOT, MULTR,
     *                  NEEDG, NEWGEQ, PEAK, PGSTOP, PSERCH, QRREAL,
     *                  ROOT, ROOTS, SEARCH, SKPMMT
C     .. Arrays in Common ..
      DOUBLE PRECISION  TADD(2),TR(3)
C     .. Local Scalars ..
      INTEGER           MMRINM
C     .. External Subroutines ..
      EXTERNAL          D02QFT, D02QFW
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, DBLE, SIGN, SQRT
C     .. Common blocks ..
      COMMON            /BD02QF/ZERO, U, FOURU, SRU, U34, U78, SRBIG,
     *                  DELSGN, TROOTS, TLEFT, SVTNEW, KROOTP, INROTP,
     *                  GSTOP, PGSTOP, ROOT, ROOTS, NEEDG, DISCOP,
     *                  NEWGEQ, SEARCH, PSERCH
      COMMON            /DD02QF/TS, GTS, TD, GTD, GM, GMX, GPREV, GMIN,
     *                  GMAX, GAVG, AMB, AMBS, SBMA, SF, DEZU34, IC,
     *                  KMC, ISING, KOUNT, KTEST, LOCEXT
      COMMON            /ED02QF/AEZ, AGTRL, AT, ATM, ATMTR, BRD, BRDS,
     *                  DDT, DELTG, DELTGM, DELTR, DG, DTG, DTGK, DTGP,
     *                  DTQR, FAC, G21, G32, GAT, GBR, GBRC, GBRMIN,
     *                  GBRMNS, GCT, GLOCMX, GMSIGN, GOLDSV, GOT, GRES,
     *                  GRIGHT, GT21, GT32, GTINT, GTQR, GTRL, GTT,
     *                  GTTMR, GVALUE, GVDIF, GVMAX, GVMIN, OMU78,
     *                  OPU78, PU, QC0, QC1, QC2, QD, QDQ, QR1, QR1N,
     *                  QR1P, QUADMN, RD, RDG, REM, REMD, REZ, ROOTNO,
     *                  SDG, SIGNG, SLOPE1, SLOPE2, SLOPEP, SOTGV, SS,
     *                  SSTU78, T21, T31, T32, TADDON, TCB, TCF, TCLOSE,
     *                  TDIF, TDMN, TDMX, TFAR, TGBRMN, TGVDIF, TGVMT,
     *                  TINT, TINTP, TK, TKOLD, TLBK, TNEW, TP, TPOINT,
     *                  TPREV, TQR, TQR1, TQR2, TQRF, TQRMP, TQRP, TQS,
     *                  TQT, TRD, TRJ, TRL, TRN, TRNOW, TROOT, TSAVE,
     *                  TSLOP, TSRU, TSTEP, TT, TU78, TUT, TZ, TZERO,
     *                  TZEROK, TZJ, TZK, TADD, TR, GRNO, GT, STTU78
      COMMON            /FD02QF/BACKR, MROOT, MULTR, PEAK, QRREAL,
     *                  SKPMMT
      COMMON            /GD02QF/I, I1, I2, I21, I3, IADD, IC1, IC2,
     *                  ICASE, ICBR, ICBRK, IDTG, IGA, IJK, IK, IKMR,
     *                  IKTQR, INDX, ISI, ISIN, ISR, ITGVT, ITRY, J, J1,
     *                  J2, J23, J3, JP1, JR, JSR, K, KGE, KP1, KROOTN,
     *                  KROOTO, KROOTS, KSKPMT, KTRY, L, LTQBIG, LTR,
     *                  MMR, MMRIN, MMRK, NSR, NTIN, NTINM, IPATH
C     .. Save statement ..
      SAVE              /DD02QF/, /BD02QF/, /ED02QF/, /FD02QF/, /GD02QF/
C     .. Executable Statements ..
C
C
      GO TO (60,20) IREVCM - 9
      GO TO 40
   20 CONTINUE
      GO TO (280,420,780,980,1700,2180,2400,2760,2880,
     *       3120,3300,3520,3740,3960) IPATH
   40 CONTINUE
      IPATH = 0
      IF ( .NOT. DISCOP) GO TO 80
C
C     FOLLOWING A ROOT OF AN EVENT FUNCTION WHICH DEFINES THE SWITCHING
C     FOR A DISCONTINUOUS PROBLEM, WE MOVE OVER BEFORE CONTINUING THE
C     ROOT SEARCH
C
      TP = T + SIGN(U78*ABS(T),DELSGN)
      IF (DELSGN*(TP-X).GE.0.D0) RETURN
      T = TP
      DISCOP = .FALSE.
      CALL RINTRP(T,Y,YPOUT,NEQ,X,YY,R,R2D)
C     CALL RDEI(GRF,NEQG,KROOT,INROOT,TKT,GOLD,PROOT,ROOTD,GP,NEEDGK,
C     1          IGSC,T,Y,YPOUT,RPAR,IPAR)
      TWANT = T
      IREVCM = 10
      RETURN
   60 CONTINUE
      IREVCM = 0
C     CALL RDEI(NEQG,KROOT,INROOT,TKT,GOLD,PROOT,ROOTD,GP,NEEDGK,IGSC,T)
      CALL D02QFW(NEQG,KROOT,INROOT,TKT,GOLD,PROOT,ROOTD,GP,NEEDGK,IGSC,
     *            T)
C
   80 IZFLAG = 0
      TROOT = X
      IF (DELSGN*(X-TOUT).GT.0.D0) TROOT = TOUT
      ROOT = .FALSE.
      IF (DELSGN*(TLEFT-TROOT).GE.0.D0) RETURN
C
C     ..................................................................
C
C     IF A ROOT HAS JUST BEEN REPORTED AT THE LAST T, MOVE OVER A SHORT
C     DISTANCE (BUT FAR ENOUGH) AND (EXCEPT IN SOME CASES FOR SIMPLE
C     ROOTS WITH NONZERO RESIDUAL) CHECK THE SPECIFIC ROOT EQUATION ONCE
C     AGAIN. (NOTHING IS DONE FOR THOSE EQUATIONS NOT HAVING A ROOT.)
C     THE SEARCH PROCEDURE IS EITHER CONTINUED OR A NEW ROOT WILL BE
C     REPORTED (DEPENDING ON THE LOCATION OF THE NEW POINT AND WHETHER
C     OR NOT A ROOT FUNCTION IS ALSO ZERO AT THE NEW POINT).
C
      IF ( .NOT. ROOTS) GO TO 340
      NEEDG = .TRUE.
      KROOTS = KROOT
      TKOLD = T
      TLEFT = TROOT
C     DO 110 K=1,NEQG
      K = 1
  100 CONTINUE
      IF (IGSC(K).NE.0) GO TO 120
      TK = TKT(K)
      GO TO 320
  120 IF (SEARCH) NEEDGK(K) = 0
      TS = TKT(K)
      IF (IGSC(K).EQ.2) GO TO 160
      IF (K.NE.KROOTS .OR. INROOT.EQ.1) GO TO 140
      TS = TROOTS
      GO TO 160
  140 GOLD(K) = GP(K)
      IF (ABS(GOLD(K)).LE.ZERO) GO TO 160
      TK = TS
      IGSC(K) = 0
      GO TO 320
  160 IGSC(K) = 0
      IF (ABS(TS).GT.ZERO) GO TO 180
      TK = SIGN(FOURU,DELSGN)
      TKT(K) = TK
      IF (DELSGN*(TK-TROOT).LT.0.D0) GO TO 240
      TINT = TROOT
      GO TO 200
  180 TINT = TS
  200 TUT = U78
      IF (INROOT.GT.1 .AND. K.EQ.KROOTS) TUT = SRU
  220 TK = TS + SIGN(TUT*ABS(TINT),DELSGN)
      IF (DELSGN*(TK-X).GT.0.D0) TK = X
      TKT(K) = TK
  240 IF (TK.EQ.TKOLD) GO TO 260
      CALL RINTRP(TK,Y,YPOUT,NEQ,X,YY,R,R2D)
      TKOLD = TK
C     80   GOLD(K) = GRF(TK,Y,YPOUT,K,RPAR,IPAR)
  260 CONTINUE
      IREVCM = 11
      IPATH = 1
      TWANT = TK
      KWANT = K
      RETURN
  280 CONTINUE
      IREVCM = 0
      GOLD(K) = GWANT
      GP(K) = GOLD(K)
      IF (ABS(GOLD(K)).GT.ZERO) GO TO 320
      IF (TUT.EQ.SRU) GO TO 300
      TUT = SRU
      GO TO 220
  300 IF (DELSGN*(TK-TROOT).GT.0.D0) GO TO 320
      ROOT = .TRUE.
      TROOT = TK
      KROOT = K
      IGSC(K) = 2
  320 IF (ABS(TK-T).LT.ABS(TLEFT-T)) TLEFT = TK
      K = K + 1
      IF (K.LE.NEQG) GO TO 100
C     110 CONTINUE
      ROOTS = .FALSE.
      IF (DELSGN*(TLEFT-TROOT).GT.0.D0) RETURN
      IF ( .NOT. ROOT .OR. TLEFT.NE.TROOT) GO TO 340
      ROOTS = .TRUE.
      INROOT = 4
      T = TROOT
      TROOTS = T
      KROOTP = KROOTS
      GO TO 4060
C
C     ..................................................................
C     ..................................................................
C
C     PERFORM A SEARCH OF THE INTERVAL (TLEFT,TROOT) FOR A POSSIBLE ROOT
C     OF SOME EVENT EQUATION.  LINEAR AND QUADRATIC INTERPOLATION ARE
C     APPLIED USING LATEST THREE DATA POINTS.
C
C                                  EVALUATE EVENT FUNCTIONS AT FAR
C                                  ENDPOINT AND CHECK ROOT CONDITIONS.
C                                  NOTE SIGN CHANGES FOUND.
  340 TNEW = TROOT
      IF (TNEW.EQ.SVTNEW) GO TO 360
      CALL RINTRP(TNEW,Y,YPOUT,NEQ,X,YY,R,R2D)
C     130 DO 230 K=1,NEQG
  360 K = 1
  380 CONTINUE
      INDX = 1
      IGSC(K) = 0
      TK = TKT(K)
      IF (DELSGN*(TK-TROOT).LT.0.D0) GO TO 400
      IF ( .NOT. SEARCH) GO TO 640
      GO TO 560
  400 IF (TNEW.EQ.SVTNEW) GO TO 440
C       GNEW(K) = GRF(TNEW,Y,YPOUT,K,RPAR,IPAR)
      TWANT = TNEW
      KWANT = K
      IREVCM = 11
      IPATH = 2
      RETURN
  420 CONTINUE
      IREVCM = 0
      GNEW(K) = GWANT
  440 IF (ABS(GNEW(K)).LE.ZERO) GO TO 460
      IF (SIGN(1.D0,GNEW(K)).EQ.SIGN(1.D0,GOLD(K))) GO TO 480
      IGSC(K) = 1
      IF (GNEW(K).LT.0.D0) IGSC(K) = -1
  460 ROOT = .TRUE.
  480 IF ( .NOT. SEARCH) GO TO 500
      IF (NEEDGK(K).EQ.0) GO TO 560
  500 IF (DELSGN*(TK-T).GE.0.D0) GO TO 520
      TLEFT = T
      TK = TLEFT
      TKT(K) = TK
  520 IF ( .NOT. SEARCH) GO TO 640
      IF (NEEDGK(K).GT.0) GO TO 560
      TDMX = 0.D0
      DO 540 J = 1, 3
         TDIF = ABS(TK-TGV(K,J))
         IF (TDIF.LE.ZERO) GO TO 580
         IF (TDIF.LE.TDMX) GO TO 540
         TDMX = TDIF
         INDX = J
  540 CONTINUE
  560 TGV(K,INDX) = TK
      GV(K,INDX) = GOLD(K)
      IF (K.EQ.KROOT) INDX = 0
      INDX = INDX + 1
      IF (INDX.GT.3) INDX = 1
      INDXG(K) = INDX
      IF (NEEDGK(K).GE.0) GO TO 640
  580 TFAR = 0.D0
      TCLOSE = SRBIG
      DO 600 L = 1, 3
         I = MIN(3,L+1)
         J = MAX(1,L-1)
         TGVDIF = ABS(TGV(K,I)-TGV(K,J))
         TFAR = MAX(TFAR,TGVDIF)
         IF (TGVDIF.GE.TCLOSE) GO TO 600
         TCLOSE = TGVDIF
         IC1 = I
         IC2 = J
  600 CONTINUE
      IF (TCLOSE.LT.MIN(0.05D0*ABS(T-TROOT),1.D-4*ABS(T))) GO TO 620
      TCF = 0.1D0
      IF (K.EQ.KROOTP .AND. INROOT.GE.2) TCF = 0.2D0
      IF (TCLOSE.GT.TCF*TFAR) GO TO 640
      IF (MAX(ABS(T-TGV(K,IC1)),ABS(T-TGV(K,IC2))).LT.0.25D0*TFAR)
     *    GO TO 640
  620 NEEDG = .TRUE.
      NEEDGK(K) = 1
      INDX = 1
      GO TO 560
C     230 CONTINUE
  640 K = K + 1
      IF (K.LE.NEQG) GO TO 380
      SVTNEW = TNEW
C                                  IF SEARCH INTERVAL IS SMALL ENOUGH,
C                                  SKIP ELABORATE SEARCHING PROCEDURE
C
      ATM = ABS(TLEFT-TROOT)
      IF (ATM.GE.0.1D0*SRU*MAX(ABS(TLEFT),ABS(TROOT)) .AND. SEARCH)
     *    GO TO 660
      IF (ROOT) GO TO 3160
      GO TO 4140
C
  660 IF ( .NOT. NEEDG) GO TO 1060
C
C                   NEED EXTRA EVENT FUNCTION EVALUATIONS FOR START OF
C                   SEARCH OPERATION AND RESTART WHEN CONTINUING AFTER
C                   A ROOT WAS FOUND.
C
C                                  WE ATTEMPT TO DETERMINE APPROPRIATE
C                                  SCALE OF EVENT FUNCTIONS NEARBY TO
C                                  THE NEW STARTING POINT BY USING AN
C                                  APPROXIMATION TO THE DERIVATIVE OF G
C                                  AND INFORMATION (IF AVAILABLE) ABOUT
C                                  THE SPREAD OF THE PREVIOUS ROOTS.
C
      DTG = DELSGN*MIN(SRU*ABS(T),ATM)
      IF (DTG.LE.ZERO) DTG = DELSGN*SRU*ATM
      TSRU = SRU*MAX(ABS(T),ATM)
      TINTP = -T
C     DO 300 K=1,NEQG
      K = 1
  680 CONTINUE
      IF (NEEDGK(K).LT.0) GO TO 840
      TK = TKT(K)
      IF (ABS(ROOTD(K)).EQ.SRBIG) GO TO 700
      REM = ABS(ROOTD(K)) - ABS(PROOT(K)-TK)
      SS = ABS(ROOTD(K))/3.D0
      IF (REM.GT.0.D0) SS = REM/3.D0
      GO TO 820
  700 IK = 0
      DTGK = DTG
  720 TINT = TK + DTGK
      IF (TINT.EQ.TINTP) GO TO 760
      IF (DELSGN*(TINT-X).LE.0.D0) GO TO 740
      SS = ATM
      GO TO 820
  740 TINTP = TINT
      CALL RINTRP(TINT,Y,YPOUT,NEQ,X,YY,R,R2D)
C     270   GTINT = GRF(TINT,Y,YPOUT,K,RPAR,IPAR)
  760 TWANT = TINT
      KWANT = K
      IREVCM = 11
      IPATH = 3
      RETURN
  780 CONTINUE
      GTINT = GWANT
      IREVCM = 0
      GVALUE = GOLD(K)
      SDG = GTINT - GVALUE
      DG = ABS(SDG)
      IF (DG.GT.U34*ABS(GTINT)) GO TO 800
      IF (DG.LE.ZERO) IK = IK + 1
      IF (IK.EQ.3) GO TO 800
      DTGK = 1000.D0*DTGK
      GO TO 720
  800 RDG = SRBIG
      IF (DG*RDG.GT.ABS(DTGK)) RDG = ABS(DTGK)/DG
      SS = RDG
      IF (SIGN(1.D0,-GVALUE)*SIGN(1.D0,SDG).EQ.-1.D0 .OR. K.EQ.KROOT)
     *    GO TO 820
      SS = 0.5D0*ABS(GVALUE)*RDG
  820 GP(K) = DELSGN*MIN(ABS(TK-TROOT)/3.D0,MAX(SS,TSRU))
C     300 CONTINUE
  840 K = K + 1
      IF (K.LE.NEQG) GO TO 680
C
C                                  OBTAIN TWO ADDITIONAL EVALUATIONS
C                                  OF EVENT FUNCTIONS. AVOID EXTRA
C                                  WORK WHEN SUCCESSIVE EVENT FUNCTIONS
C                                  HAVE NEARLY THE SAME SCALE.
C                                  NOTE SIGN CHANGES FOUND.
      NEEDG = .FALSE.
C     DO 370 J=1,2
      J = 1
  860 CONTINUE
      DTGP = 0.D0
C       DO 360 K=1,NEQG
      K = 1
  880 CONTINUE
      IF (NEEDGK(K).LT.0) GO TO 1040
      TK = TKT(K)
      DTG = GP(K)
      IF (ABS(DTG).LT.4.D0*ABS(DTGP) .AND. ABS(DTGP).LT.4.D0*ABS(DTG))
     *    GO TO 900
      IDTG = 0
      DTGP = DTG
      GO TO 920
  900 IDTG = 1
      DTG = DTGP
  920 TINT = TK + DBLE(J)*DTG
      IF (DELSGN*(TINT-X).LE.0.D0) GO TO 940
      NEEDG = .TRUE.
      GO TO 1040
  940 IF (IDTG.EQ.1) GO TO 960
      CALL RINTRP(TINT,Y,YPOUT,NEQ,X,YY,R,R2D)
C     330     GTINT = GRF(TINT,Y,YPOUT,K,RPAR,IPAR)
  960 TWANT = TINT
      KWANT = K
      IREVCM = 11
      IPATH = 4
      RETURN
  980 CONTINUE
      GTINT = GWANT
      IREVCM = 0
      IF (ABS(GTINT).LE.ZERO) GO TO 1000
      IF (SIGN(1.D0,GTINT).EQ.SIGN(1.D0,GOLD(K))) GO TO 1020
      IGSC(K) = 1
      IF (GTINT.LT.0.D0) IGSC(K) = -1
 1000 ROOT = .TRUE.
      IF (DELSGN*(TINT-TROOT).LT.0.D0) TROOT = TINT
      IF (J.EQ.2) GO TO 1020
      GP(K) = 0.25D0*DTG
 1020 TGV(K,J+1) = TINT
      GV(K,J+1) = GTINT
      IF (J.EQ.2) NEEDGK(K) = -1
C     360   CONTINUE
 1040 K = K + 1
      IF (K.LE.NEQG) GO TO 880
C     370 CONTINUE
      J = J + 1
      IF (J.LE.2) GO TO 860
C
C                   PERFORM AN INTERVAL SEARCH FOR EACH EVENT EQUATION.
C                   FOR A GIVEN EQUATION, THE SEARCH IS TERMINATED WHEN
C                    (1) A SIGN CHANGE IS ISOLATED,  OR
C                    (2) NONE OF THE SECANT OR QUADRATIC ROOT POINTS LIE
C                        WITHIN THE SEARCH INTERVAL ON TWO ATTEMPTS,  OR
C                    (3) TOO MANY EVALUATIONS OF THE EVENT EQUATION ARE
C                        MADE.
C
 1060 MROOT = .FALSE.
      TZERO = TROOT
      MMR = 0
      OMU78 = 1.D0 - U78
      OPU78 = 1.D0 + U78
      TU78 = 10.D0*U78
      STTU78 = DELSGN*2.D0*TU78
C
C     DO 1300 K=1,NEQG
      K = 1
 1080 CONTINUE
      KWANT = K
      T = TKT(K)
      IF (DELSGN*(T-TROOT).GE.0.D0 .OR. NEEDGK(K).GE.0) GO TO 3020
C
C                                 OBTAIN SLOPE OF THE CURVE AT THE START
C                                 OF THE STEP
      TSLOP = T
      TPOINT = T
      J1 = 1
      SOTGV = TGV(K,1)
      DO 1100 J = 2, 3
         IF (DELSGN*TGV(K,J).GT.DELSGN*SOTGV) GO TO 1100
         SOTGV = TGV(K,J)
         J1 = J
 1100 CONTINUE
      J2 = J1 + 1
      IF (J2.GT.3) J2 = 1
      J3 = J2 + 1
      IF (J3.GT.3) J3 = 1
      IF (DELSGN*TGV(K,J2).LT.DELSGN*TGV(K,J3)) GO TO 1120
      J23 = J2
      J2 = J3
      J3 = J23
 1120 GVDIF = GV(K,J3) - GV(K,J2)
      IF (SIGN(1.D0,TGV(K,J2)-T).EQ.DELSGN) GVDIF = GV(K,J2) - GV(K,J1)
      SLOPEP = 0.D0
      IF (GVDIF.NE.0.D0) SLOPEP = SIGN(1.D0,GVDIF)*SIGN(1.D0,GOLD(K))
C
      KTRY = 1
      KGE = 0
      IKMR = 0
      TQRP = DELSGN*SRBIG
      RD = SRBIG
      IF (ABS(ROOTD(K)).EQ.SRBIG) GO TO 1140
      REMD = ABS(ROOTD(K)) - ABS(PROOT(K)-T)
      RD = ABS(ROOTD(K))
      IF (REMD.GT.0.D0) RD = REMD
 1140 ICBR = 0
      ICBRK = 2
      IF (K.NE.KROOT) GO TO 1160
      IF (INROOT.EQ.2) ICBRK = 4
      GO TO 1180
 1160 IF (K.NE.KROOTP) GO TO 1180
      IF (INROTP.EQ.2) ICBRK = 4
 1180 BRD = DELSGN*(TGV(K,J2)-T)
      BRDS = BRD
      GBRMIN = ABS(GV(K,J2))
      GBRMNS = GBRMIN
      GBRC = GBRMIN
      DELTR = 0.75D0*MAX(ABS(TGV(K,1)-T),ABS(TGV(K,2)-T),ABS(TGV(K,3)-T)
     *        )
      BACKR = .FALSE.
      LOCEXT = .FALSE.
      PEAK = .FALSE.
      SKPMMT = .FALSE.
      KSKPMT = 0
      GLOCMX = 0.D0
C
C                **** PLACE OF LOOPING BACK IN THE SEARCH PROCEDURE ****
C
C                                 ASSIGN INDICES CORRESPONDING TO GV
C                                 VALUES WHICH ARE IN INCREASING ORDER
C                                 OF MAGNITUDES
C
 1200 GVMIN = ABS(GV(K,1))
      I3 = 1
      DO 1220 J = 2, 3
         IF (ABS(GV(K,J)).GE.GVMIN) GO TO 1220
         GVMIN = ABS(GV(K,J))
         I3 = J
 1220 CONTINUE
      I1 = I3 + 1
      IF (I1.GT.3) I1 = 1
      I2 = I1 + 1
      IF (I2.GT.3) I2 = 1
      IF (ABS(GV(K,I2)).LE.ABS(GV(K,I1))) GO TO 1240
      I21 = I1
      I1 = I2
      I2 = I21
 1240 GVMAX = ABS(GV(K,I1))
      GLOCMX = MAX(GLOCMX,GVMAX)
C
C                                 COMPUTE ROOTS OF QUADRATIC FIT
C
      T21 = TGV(K,I2) - TGV(K,I1)
      G21 = GV(K,I2) - GV(K,I1)
      IF (ABS(G21).GE.ABS(T21)*SRBIG) GO TO 2860
      T32 = TGV(K,I3) - TGV(K,I2)
      G32 = GV(K,I3) - GV(K,I2)
      IF (ABS(G32).GE.ABS(T32)*SRBIG) GO TO 2860
      GT21 = G21/T21
      GT32 = G32/T32
      T31 = TGV(K,I3) - TGV(K,I1)
      QC2 = GT32 - GT21
      QC1 = T31*GT32 + T32*QC2
      QC0 = T31*GV(K,I3)
      QDQ = QC1**2 - 4.D0*QC2*QC0
      QD = SQRT(ABS(QDQ))
      QR1P = -QC1 + QD
      QR1N = -QC1 - QD
      QR1 = QR1P
      IF (QC1.GT.0.D0) QR1 = QR1N
      IF (ABS(QR1).GT.ZERO) GO TO 1260
      IF (ABS(QC2).LE.ZERO) GO TO 2860
      TQR = TGV(K,I3)
      TQR1 = TQR
      TQR2 = TQR
      LTQBIG = 0
      GO TO 1380
 1260 IF (QDQ.GT.ZERO) GO TO 1300
      IF (QC1.GT.0.D0) GO TO 1280
      TQR1 = QR1N/(2.D0*QC2) + TGV(K,I3)
      GO TO 1320
 1280 TQR1 = QR1P/(2.D0*QC2) + TGV(K,I3)
      GO TO 1320
 1300 TQR1 = 2.D0*QC0/QR1 + TGV(K,I3)
      IF (ABS(QR1).GE.ABS(2.D0*QC2)*SRBIG) GO TO 1340
 1320 TQR2 = QR1/(2.D0*QC2) + TGV(K,I3)
      LTQBIG = 1
      GO TO 1360
 1340 TQR2 = SRBIG
      IF (SIGN(1.D0,TGV(K,1)-TQR1).EQ.DELSGN) TQR2 = -SRBIG
      LTQBIG = -1
 1360 TQR = TQR1 + 0.5D0*(TQR2-TQR1)
C                                 ORDER QUADRATIC ROOTS
      IF (SIGN(1.D0,TQR2-TQR1).EQ.DELSGN) GO TO 1380
      TQS = TQR1
      TQR1 = TQR2
      TQR2 = TQS
C
C                                 SET INDICATOR FOR ROOTS BEING REAL
C                                 OR COMPLEX
 1380 QRREAL = .TRUE.
      IF (QDQ.LT.-ZERO) QRREAL = .FALSE.
C
C                                 SET INDICATOR WHEN A ROOT OF EVEN
C                                 MULTIPLICITY IS POSSIBLE
      MULTR = .FALSE.
      IF (SIGN(1.D0,TQR-T).EQ.SIGN(1.D0,TQR-TROOT)) GO TO 1400
      IF (ABS(TQR2-TQR1).GE.0.01D0*ABS(TQR)) GO TO 1400
      QUADMN = SRBIG
      IF (ABS(QDQ).LT.ABS(QC2*T31)*SRBIG)
     *    QUADMN = ABS(QDQ/(-4.D0*QC2*T31))
      IF (GLOCMX.GE.20.D0*QUADMN) MULTR = .TRUE.
C
C                                 SET CERTAIN CONCAVITY AND POINT
C                                 PLACEMENT INDICATORS TO AID IN
C                                 REDUCING THE WORK EFFORT IN
C                                 APPROPRIATE CIRCUMSTANCES.
 1400 IKTQR = 0
      ITGVT = -1
      DO 1440 J = 1, 3
         TGVMT = (TGV(K,J)-T)*DELSGN
         IF (TGVMT.LE.ZERO) GO TO 1420
         ITGVT = 1
         DELTR = MAX(0.75D0*ABS(TGVMT),DELTR)
 1420    IF (DELSGN*(TGV(K,J)-TQR).LE.ZERO) GO TO 1440
         IKTQR = IKTQR + 1
         IJK = J
 1440 CONTINUE
C
C
C                                 BASED ON CONCAVITY, POINT LOCATIONS,
C                                 AND WHETHER THE QUADRATIC ROOTS ARE
C                                 REAL OR COMPLEX, DETERMINE THE SET OF
C                                 SEARCH POINTS
C
C
      NTIN = 0
      NSR = 3
      ITRY = 0
      ICASE = 0
      IF ( .NOT. QRREAL) GO TO 1620
C                                       ROOTS REAL
      GMSIGN = -1.D0
      IF (LTQBIG.EQ.0) GO TO 1480
      GMSIGN = SIGN(1.D0,T31)*SIGN(1.D0,GOLD(K))
      IF (LTQBIG.LT.0) GO TO 1460
      GMSIGN = GMSIGN*SIGN(1.D0,-QC2)
      GO TO 1480
 1460 GMSIGN = GMSIGN*DELSGN*SIGN(1.D0,QC1)*SIGN(1.D0,TQR)
C
 1480 IF (GMSIGN.GT.0.D0) GO TO 1540
      IF (IKTQR.NE.1) GO TO 1500
      ICASE = 1
      IF (SIGN(1.D0,T-TQR).EQ.DELSGN) GO TO 1900
 1500 IF (IKTQR.GT.1 .AND. K.EQ.KROOT .AND. KGE.EQ.0) GO TO 1520
      IF (IKTQR.GT.1 .AND. ITGVT.LT.0) GO TO 1860
      IF (IKTQR.GT.1 .AND. BACKR) GO TO 1800
      ICASE = 2
      TQR1 = OPU78*TQR1
      TQR2 = OMU78*TQR2
      GO TO 1880
 1520 IF (IKTQR.EQ.3) GO TO 1840
      ICASE = 3
      LTR = 2
      TR(1) = TQR
      TR(2) = OMU78*TQR2
      GO TO 1960
 1540 NSR = 1
      J1 = 1
      SOTGV = TGV(K,1)
      DO 1560 J = 2, 3
         IF (DELSGN*TGV(K,J).GT.DELSGN*SOTGV) GO TO 1560
         SOTGV = TGV(K,J)
         J1 = J
 1560 CONTINUE
      J2 = J1 + 1
      IF (J2.GT.3) J2 = 1
      J3 = J2 + 1
      IF (J3.GT.3) J3 = 1
      IF (DELSGN*TGV(K,J2).LT.DELSGN*TGV(K,J3)) GO TO 1580
      J23 = J2
      J2 = J3
      J3 = J23
 1580 ISR = J2
      TQR1 = OMU78*TQR1
      TQR2 = OPU78*TQR2
      IF (IKTQR.LE.1) GO TO 1600
      ICASE = 4
      JSR = J3
      GO TO 1900
 1600 ICASE = 5
      JSR = J1
      GO TO 1900
C
C                                          ROOTS COMPLEX
 1620 IF (IKTQR.GT.0) GO TO 1680
      IF (SIGN(1.D0,TROOT-TQR).EQ.DELSGN) GO TO 1640
      ICASE = 6
      LTR = 1
      NSR = 1
      ISR = I2
      JSR = I3
      GO TO 1900
 1640 ICASE = 7
      TQRF = TQR + (TQR2-TQR1)
      IF (SIGN(1.D0,TQRF-TROOT).EQ.DELSGN) GO TO 1660
      LTR = 2
      TR(1) = TQR
      TR(2) = TQRF
      GO TO 1960
 1660 LTR = 1
      TR(1) = TQR2
      GO TO 1960
 1680 IF (IKTQR.GE.2) GO TO 1760
      ICASE = 8
      IF (SIGN(1.D0,T-TQR).EQ.DELSGN) GO TO 1900
      CALL RINTRP(TQR,Y,YPOUT,NEQ,X,YY,R,R2D)
C       GTQR = GRF(TQR,Y,YPOUT,K,RPAR,IPAR)
      IREVCM = 11
      IPATH = 5
      TWANT = TQR
      RETURN
 1700 CONTINUE
      GTQR = GWANT
      IREVCM = 0
      KGE = KGE + 1
      IF (ABS(GTQR).LE.ZERO) GO TO 1720
      IF (SIGN(1.D0,GTQR).EQ.SIGN(1.D0,GOLD(K))) GO TO 1740
      IGSC(K) = 1
      IF (GTQR.LT.0.D0) IGSC(K) = -1
 1720 ROOT = .TRUE.
      TROOT = TQR
      GO TO 3020
 1740 IF (ABS(GTQR).LT.GVMIN) GO TO 1780
      ICASE = 9
      LTR = 1
      TR(1) = TGV(K,IJK) + (TGV(K,IJK)-TGV(K,I1))
      GO TO 1960
 1760 IF (K.EQ.KROOT .AND. KGE.EQ.0) GO TO 1820
      IF (ITGVT.LT.0) GO TO 1860
 1780 IF (IKTQR.EQ.3) GO TO 1800
      IF (BACKR) GO TO 1800
      ICASE = 10
      TQR1 = OPU78*TQR1
      TQR2 = OMU78*TQR2
      GO TO 1880
 1800 ICASE = 11
      LTR = 2
      TQT = 0.5D0*(T+TQR)
      IF (LOCEXT) TQT = TQR - (TQR2-TQR1)
      TR(1) = TQT
      TR(2) = TQR
      GO TO 1960
 1820 IF (IKTQR.EQ.3) GO TO 1840
      ICASE = 12
      LTR = 1
      TR(1) = TQR
      GO TO 1960
C
 1840 IF (5.D0*DELTR.LT.ABS(T-TROOT)) GO TO 2360
      ICASE = 13
      KTRY = 0
      TPOINT = TGV(K,3)
      GO TO 2860
C
 1860 IF (ABS(GNEW(K)).GE.GVMAX .OR. 5.D0*DELTR.LT.ABS(T-TROOT))
     *    GO TO 2360
      ICASE = 14
      KTRY = 0
      TPOINT = T
      GO TO 2860
C
 1880 LTR = 3
      TR(1) = TQR1
      TR(2) = TQR
      TR(3) = TQR2
      GO TO 1960
C                                 COMPUTE SECANT ROOTS
 1900 DO 1940 L = 1, NSR
         IF (NSR.EQ.1) GO TO 1920
         ISR = MIN(3,L+1)
         JSR = MAX(1,L-1)
 1920    TRN = GV(K,ISR)*(TGV(K,JSR)-TGV(K,ISR))
         TRD = GV(K,ISR) - GV(K,JSR)
         TRNOW = SRBIG
         IF (ABS(TRN).LT.ABS(TRD)*SRBIG) TRNOW = TGV(K,ISR) + TRN/TRD
         TR(L) = TRNOW
 1940 CONTINUE
C
      IF (ICASE.EQ.6) GO TO 1960
      LTR = 3
      IF (ICASE.EQ.1 .OR. ICASE.EQ.8) GO TO 1960
      TR(2) = TQR2
      TR(3) = TQR1
      IF (ICASE.EQ.4) LTR = 2
C
C                                 DETERMINE WHICH OF THE SECANT AND
C                                 QUADRATIC ROOT POINTS LIE WITHIN THE
C                                 SEARCH INTERVAL AND ARE ACCEPTABLE
C
 1960 NTIN = 0
      DO 2080 L = 1, LTR
         STTU78 = -STTU78
         TRL = TR(L)
 1980    IF (TRL.EQ.T .OR. TRL.EQ.TROOT) GO TO 2080
         IF (SIGN(1.D0,TRL-T).EQ.SIGN(1.D0,TRL-TROOT)) GO TO 2080
         IF (ABS(TRL-T).GT.5.D0*DELTR) GO TO 2080
         IF (ICASE.NE.5) GO TO 2000
         IF (K.NE.KROOT .AND. K.NE.KROOTP .OR. ABS(TRL-T)
     *       .GT.1.D-4*ABS(T)) GO TO 2000
         IF (ABS(T-TROOT).LT.0.001D0*ABS(T)) GO TO 2000
         IKMR = 0
         GO TO 2080
 2000    DO 2020 J = 1, 3
            IF (ABS(TRL-TGV(K,J)).GE.TU78*ABS(TRL)) GO TO 2020
            TRL = TRL*(1.D0+STTU78)
            GO TO 1980
 2020    CONTINUE
         IF (NTIN.EQ.0) GO TO 2060
         DO 2040 J = 1, NTIN
            IF (ABS(TRL-TR(J)).GE.TU78*ABS(TRL)) GO TO 2040
            TRL = TRL*(1.D0+STTU78)
            GO TO 1980
 2040    CONTINUE
 2060    NTIN = NTIN + 1
         TR(NTIN) = TRL
 2080 CONTINUE
C
C
C                                 REORDER THE TR POINTS (LYING INSIDE
C                                 THE SEARCH INTERVAL) IN INCREASING
C                                 DISTANCES FROM T
      IF (NTIN.EQ.0) GO TO 2240
      IF (NTIN.EQ.1) GO TO 2140
      NTINM = NTIN - 1
      DO 2120 J = 1, NTINM
         TRJ = TR(J)
         JP1 = J + 1
         DO 2100 L = JP1, NTIN
            TRL = TR(L)
            IF (ABS(TRJ-T).LE.ABS(TRL-T)) GO TO 2100
            TR(J) = TRL
            TR(L) = TRJ
            TRJ = TRL
 2100    CONTINUE
 2120 CONTINUE
C
C                                 USE THE ACCEPTABLE SEARCH POINTS TO
C                                 LOOK FOR A SIGN CHANGE OF THE K-TH
C                                 EVENT FUNCTION
C
C     910   DO 940 L=1,NTIN
 2140 L = 1
 2160 CONTINUE
      TRL = TR(L)
      CALL RINTRP(TRL,Y,YPOUT,NEQ,X,YY,R,R2D)
C         GTRL = GRF(TRL,Y,YPOUT,K,RPAR,IPAR)
      IREVCM = 11
      IPATH = 6
      TWANT = TRL
      RETURN
 2180 CONTINUE
      GTRL = GWANT
      IREVCM = 0
      KGE = KGE + 1
      AGTRL = ABS(GTRL)
      IF (AGTRL.LE.ZERO) GO TO 2200
      IF (SIGN(1.D0,GTRL).EQ.SIGN(1.D0,GOLD(K))) GO TO 2220
      IGSC(K) = 1
      IF (GTRL.LT.0.D0) IGSC(K) = -1
 2200 ROOT = .TRUE.
      TROOT = TRL
      GO TO 3020
C
 2220 IF (L.EQ.1) GBR = ABS(GTRL)
      IF (L.EQ.2) GBRC = ABS(GTRL)
      IF (L.GT.1 .AND. ABS(GTRL).GT.GVMAX) GO TO 2240
      INDX = INDXG(K)
      TGV(K,INDX) = TRL
      GV(K,INDX) = GTRL
      INDX = INDX + 1
      IF (INDX.GT.3) INDX = 1
      INDXG(K) = INDX
C     940   CONTINUE
      L = L + 1
      IF (L.LE.NTIN) GO TO 2160
C
C                                  CHECK FOR POSSIBLE ROOT OF EVEN
C                                  MULTIPLICITY
C
 2240 DTQR = TQRP - TQR
      TQRP = TQR
      IF (ABS(DTQR).GT.1.D-3*MIN(1.0D0,MAX(1.D+3*SRU,2.D0*ABS(TROOT-T)
     *    /MAX(ABS(T),ABS(TROOT))))*ABS(TQR)) GO TO 2280
      IKMR = IKMR + 1
      IF (IKMR.LT.2) GO TO 2300
      IF (MULTR) GO TO 2260
      IF (QRREAL) GO TO 2280
      IKMR = 0
      GO TO 2860
 2260 IF (LOCEXT) GO TO 3000
      SKPMMT = .FALSE.
      KSKPMT = 0
      GO TO 2300
 2280 IKMR = 0
C
C                                  CHECK FOR SPECIAL CASES SUCH AS
C                                  CONVERGING BACK TO PREVIOUS ROOT;
C                                  LOOP BACK FOR FURTHER SEARCHING
 2300 BACKR = .FALSE.
      IF (NTIN.EQ.0) GO TO 2360
      IF (K.NE.KROOT .AND. K.NE.KROOTP) GO TO 2520
      TCB = TQR
      IF (NTIN.EQ.1) TCB = TR(1)
      ATMTR = ABS(T-TCB)
      IF (ATMTR.GE.BRD) GO TO 2520
      IF (ICASE.NE.2 .AND. ICASE.NE.3 .AND. ICASE.NE.10 .AND. ICASE.NE.
     *    11) GO TO 2340
      IF (IKTQR.LT.2) GO TO 2340
      BRD = ATMTR
      BACKR = .TRUE.
      GBRMIN = MIN(GBRMIN,GBR)
      IF (GBR.LT.GBRC .AND. GBR.LE.GBRMIN) GO TO 2320
      BACKR = .FALSE.
      LOCEXT = .TRUE.
      GO TO 2340
 2320 ICBR = ICBR + 1
      IF (ICBR.LT.ICBRK) GO TO 2520
      ICBR = 0
      ICBRK = 1
      IF (INROOT.EQ.2 .AND. K.EQ.KROOT) ICBRK = 2
      IF (INROTP.EQ.2 .AND. K.EQ.KROOTP) ICBRK = 2
      BRD = BRDS
      GBRMIN = GBRMNS
      GBRC = GBRMIN
      ITRY = -1
      GO TO 2360
 2340 ICBR = 0
      GO TO 2520
C
C
C                                  WANT TO ENSURE THAT THE SPREAD OF THE
C                                  SEARCHING POINTS IS COMPARABLE TO THE
C                                  SIZE OF THE SEARCH INTERVAL;LOOP BACK
C
 2360 DDT = DELTR
      IF (ITRY.NE.-1) DDT = MIN(DDT,0.2D0*RD)
      IF (5.D0*DDT.GE.ABS(T-TROOT)) GO TO 2520
      IF (DDT.NE.DELTR) RD = SRBIG
      DDT = 2.5D0*DELSGN*DDT
C       DO 1060 ISI=1,2
      ISI = 1
 2380 CONTINUE
      TINT = T + DBLE(ISI)*DDT
      CALL RINTRP(TINT,Y,YPOUT,NEQ,X,YY,R,R2D)
C         GTINT = GRF(TINT,Y,YPOUT,K,RPAR,IPAR)
      IREVCM = 11
      IPATH = 7
      TWANT = TINT
      RETURN
 2400 CONTINUE
      GTINT = GWANT
      IREVCM = 0
      KGE = KGE + 1
      IF (ABS(GTINT).LE.ZERO) GO TO 2420
      IF (SIGN(1.D0,GTINT).EQ.SIGN(1.D0,GOLD(K))) GO TO 2440
      IGSC(K) = 1
      IF (GTINT.LT.0.D0) IGSC(K) = -1
 2420 ROOT = .TRUE.
      TROOT = TINT
 2440 INDX = 0
      TDMX = 0.D0
      TDMN = SRBIG
      DO 2480 J = 1, 3
         TGVMT = TGV(K,J) - T
         IF (SIGN(1.D0,TGVMT).EQ.DELSGN) GO TO 2460
         IF (ABS(TGVMT).LE.TDMX) GO TO 2480
         TDMX = ABS(TGVMT)
         INDX = J
         GO TO 2480
 2460    IF (TDMX.GT.0.D0) GO TO 2480
         IF (ABS(TGVMT).GE.TDMN) GO TO 2480
         TDMN = ABS(TGVMT)
         INDX = J
 2480 CONTINUE
      IF (INDX.EQ.0) INDX = INDXG(K)
      TGV(K,INDX) = TINT
      GV(K,INDX) = GTINT
      INDX = INDX + 1
      IF (INDX.GT.3) INDX = 1
      INDXG(K) = INDX
      IF (ISI.EQ.2) GO TO 2500
      GBRMIN = ABS(GTINT)
      TGBRMN = TINT
C     1060   CONTINUE
 2500 ISI = ISI + 1
      IF (ISI.LE.2) GO TO 2380
      ITRY = 1
      GBRMNS = GBRMIN
      GBRC = GBRMIN
      BRD = ABS(T-TGBRMN)
      BRDS = BRD
C
C                                SEE IF LOCAL MIN OR MAX OCCURS AND
C                                ADD APPROPRIATE POINTS FOR THE SEARCH.
C
 2520 IF (ITRY.LT.0) GO TO 2860
      IF (SKPMMT) GO TO 2840
      IF (BACKR) GO TO 2840
      IF (SLOPEP.EQ.0.D0) GO TO 2840
 2540 J1 = 1
      SOTGV = TGV(K,1)
      DO 2560 J = 2, 3
         IF (DELSGN*TGV(K,J).GT.DELSGN*SOTGV) GO TO 2560
         SOTGV = TGV(K,J)
         J1 = J
 2560 CONTINUE
      J2 = J1 + 1
      IF (J2.GT.3) J2 = 1
      J3 = J2 + 1
      IF (J3.GT.3) J3 = 1
      IF (DELSGN*TGV(K,J2).LT.DELSGN*TGV(K,J3)) GO TO 2580
      J23 = J2
      J2 = J3
      J3 = J23
 2580 IF (DELSGN*(TGV(K,J3)-T).LE.0.D0) GO TO 2860
      SLOPE1 = SIGN(1.D0,GV(K,J2)-GV(K,J1))*SIGN(1.D0,GOLD(K))
      SLOPE2 = SIGN(1.D0,GV(K,J3)-GV(K,J2))*SIGN(1.D0,GOLD(K))
C
      IF (SLOPEP.GT.0.D0) GO TO 2600
      IF (SLOPE1.GE.0.D0) GO TO 2640
      PEAK = .FALSE.
      IF (SLOPE2.GE.0.D0) GO TO 2680
      GO TO 2840
 2600 IF (SLOPE1.GT.0.D0) GO TO 2620
      SLOPEP = -1.D0
      TSLOP = TGV(K,J1)
      IF (SLOPE2.GE.0.D0) GO TO 2680
      GO TO 2700
 2620 IF (SLOPE2.LE.0.D0) GO TO 2700
      GO TO 2840
C
 2640 IF (PEAK) GO TO 2840
      INDX = J1 + 1
      IF (INDX.GT.3) INDX = 1
      LOCEXT = .TRUE.
      IF (TGV(K,J1).EQ.TSLOP) GO TO 2660
      TADD(1) = 0.5D0*(TSLOP+TGV(K,J1))
      TADD(2) = 0.5D0*(TGV(K,J1)+TGV(K,J2))
      GO TO 2720
 2660 TADDON = (TGV(K,J2)-TGV(K,J1))/3.D0
      TADD(1) = TGV(K,J1) + TADDON
      TADD(2) = TGV(K,J1) + 2.D0*TADDON
      GO TO 2720
 2680 TADD(1) = 0.5D0*(TGV(K,J1)+TGV(K,J2))
      TADD(2) = 0.5D0*(TGV(K,J2)+TGV(K,J3))
      INDX = J2 + 1
      IF (INDX.GT.3) INDX = 1
      LOCEXT = .TRUE.
      PEAK = .FALSE.
      GO TO 2720
 2700 SLOPEP = -1.D0
      PEAK = .TRUE.
      TSLOP = TGV(K,J2)
      TADDON = (TGV(K,J3)-TGV(K,J2))/3.D0
      TADD(1) = TGV(K,J2) + TADDON
      TADD(2) = TGV(K,J2) + 2.D0*TADDON
      INDX = J3 + 1
      IF (INDX.GT.3) INDX = 1
C
 2720 IADD = 0
C       DO 1200 ISI=1,2
      ISI = 1
 2740 CONTINUE
      TINT = TADD(ISI)
      IF (SIGN(1.D0,TINT-T).EQ.SIGN(1.D0,TINT-TROOT)) GO TO 2820
      IADD = IADD + 1
      CALL RINTRP(TINT,Y,YPOUT,NEQ,X,YY,R,R2D)
C         GTINT = GRF(TINT,Y,YPOUT,K,RPAR,IPAR)
      IREVCM = 11
      IPATH = 8
      TWANT = TINT
      RETURN
 2760 CONTINUE
      GTINT = GWANT
      IREVCM = 0
      KGE = KGE + 1
      IF (ABS(GTINT).LE.ZERO) GO TO 2780
      IF (SIGN(1.D0,GTINT).EQ.SIGN(1.D0,GOLD(K))) GO TO 2800
      IGSC(K) = 1
      IF (GTINT.LT.0.D0) IGSC(K) = -1
 2780 ROOT = .TRUE.
      TROOT = TINT
      GO TO 3020
 2800 TGV(K,INDX) = TINT
      GV(K,INDX) = GTINT
      INDX = INDX + 1
      IF (INDX.GT.3) INDX = 1
C     1200   CONTINUE
 2820 ISI = ISI + 1
      IF (ISI.LE.2) GO TO 2740
      INDXG(K) = INDX
      IF (LOCEXT) KSKPMT = KSKPMT + 1
      IF (KSKPMT.GE.2) SKPMMT = .TRUE.
      IF (IADD.GT.0 .AND. KGE.LT.50) GO TO 1200
C
 2840 IF (NTIN.GT.0 .AND. KGE.LT.50) GO TO 1200
      IF (ITRY.EQ.1 .AND. KGE.LT.50) GO TO 1200
C
C                                 USE THE FINAL ENDPOINT AS ANOTHER TRY;
C                                 IN SOME CIRCUMSTANCES, INCLUDE A
C                                 MIDPOINT VALUE FOR SEARCHING
C
 2860 KTRY = KTRY + 1
      IF (KTRY.GT.2) GO TO 3020
      IF (KTRY.EQ.2) GO TO 2940
      TINT = 0.5D0*(TNEW+TPOINT)
      IF (SIGN(1.D0,TINT-T).EQ.SIGN(1.D0,TINT-TROOT)) GO TO 2940
      CALL RINTRP(TINT,Y,YPOUT,NEQ,X,YY,R,R2D)
C       GTINT = GRF(TINT,Y,YPOUT,K,RPAR,IPAR)
      IREVCM = 11
      IPATH = 9
      TWANT = TINT
      RETURN
 2880 CONTINUE
      GTINT = GWANT
      IREVCM = 0
      KGE = KGE + 1
      IF (ABS(GTINT).LE.ZERO) GO TO 2900
      IF (SIGN(1.D0,GTINT).EQ.SIGN(1.D0,GOLD(K))) GO TO 2920
      IGSC(K) = 1
      IF (GTINT.LT.0.D0) IGSC(K) = -1
 2900 ROOT = .TRUE.
      TROOT = TINT
      GO TO 3020
 2920 INDX = INDXG(K)
      TGV(K,INDX) = TINT
      GV(K,INDX) = GTINT
      INDX = INDX + 1
      IF (INDX.GT.3) INDX = 1
      INDXG(K) = INDX
 2940 KTRY = 2
      IKMR = 0
      INDX = 0
      TDMX = 0.D0
      TDMN = SRBIG
      DO 2980 J = 1, 3
         TGVMT = TGV(K,J) - T
         IF (SIGN(1.D0,TGVMT).EQ.DELSGN) GO TO 2960
         IF (ABS(TGVMT).LE.TDMX) GO TO 2980
         TDMX = ABS(TGVMT)
         INDX = J
         GO TO 2980
 2960    IF (TDMX.GT.0.D0) GO TO 2980
         IF (ABS(TGVMT).GE.TDMN) GO TO 2980
         TDMN = ABS(TGVMT)
         INDX = J
 2980 CONTINUE
      IF (INDX.EQ.0) INDX = INDXG(K)
      TGV(K,INDX) = TNEW
      GV(K,INDX) = GNEW(K)
      INDX = INDX + 1
      IF (INDX.GT.3) INDX = 1
      INDXG(K) = INDX
      BRD = BRDS
      GBRMIN = GBRMNS
      GBRC = GBRMIN
      SKPMMT = .FALSE.
      KSKPMT = 0
      IF (SLOPEP.EQ.0.D0) GO TO 1200
      ITRY = 1
      GO TO 2540
C
C                                  POSSIBLE ROOT OF EVEN MULTIPLICITY
 3000 MROOT = .TRUE.
      TQRMP = TQR + 0.5D0*DTQR
      DTQR = MAX(ABS(DTQR),U34*ABS(TQRMP))
      TZEROK = TQRMP + 4.D0*DELSGN*DTQR
      IF (SIGN(1.D0,TZEROK-T).EQ.SIGN(1.D0,TZEROK-TROOT)) TZEROK = TROOT
      IF (ABS(TZERO-T).GT.ABS(TZEROK-T)) TZERO = TZEROK
      TPREV = TQRMP - 4.D0*DELSGN*DTQR
      IF (SIGN(1.D0,TPREV-T).EQ.SIGN(1.D0,TPREV-TROOT)) TPREV = T
      MMR = MMR + 1
      MMREQ(MMR) = K
      TLBMR(MMR) = TPREV
      TRBMR(MMR) = TZEROK
C
C     1300 CONTINUE
 3020 K = K + 1
      IF (K.LE.NEQG) GO TO 1080
C
C     ..................................................................
C     ..................................................................
C
      IF ( .NOT. MROOT) GO TO 3140
      IF (ROOT .AND. DELSGN*(TZERO-TROOT).GE.0.D0) GO TO 3160
C
C                                  THE POSSIBILITY OF A ROOT OF EVEN
C                                  MULTIPLICITY WILL ALSO BE EXAMINED.
C                                  FIRST, REORDER POINTS WHERE ROOTS OF
C                                  EVEN MULTIPLICITY ARE POSSIBLE.
C
      MMRIN = 0
      DO 3040 K = 1, MMR
         TZ = TRBMR(K)
         IF (DELSGN*(TZ-TROOT).GT.0.D0) GO TO 3040
         MMRIN = MMRIN + 1
         MMREQ(MMRIN) = MMREQ(K)
         TLBMR(MMRIN) = TLBMR(K)
         TRBMR(MMRIN) = TZ
 3040 CONTINUE
      IF (MMRIN.EQ.0) GO TO 3140
      MMR = 1
      IF (MMRIN.EQ.1) GO TO 3100
      MMRINM = MMRIN - 1
      DO 3080 K = 1, MMRINM
         TZK = TRBMR(K)
         KP1 = K + 1
         DO 3060 J = KP1, MMRIN
            TZJ = TRBMR(J)
            IF (ABS(TZK-TLEFT).LE.ABS(TZJ-TLEFT)) GO TO 3060
            TRBMR(K) = TZJ
            TRBMR(J) = TZK
            TZK = TZJ
            MMRK = MMREQ(K)
            MMREQ(K) = MMREQ(J)
            MMREQ(J) = MMRK
            TLBK = TLBMR(K)
            TLBMR(K) = TLBMR(J)
            TLBMR(J) = TLBK
 3060    CONTINUE
 3080 CONTINUE
 3100 TZERO = TRBMR(MMR)
      TPREV = TLBMR(MMR)
      KROOTO = MMREQ(MMR)
      CALL RINTRP(TPREV,Y,YPOUT,NEQ,X,YY,R,R2D)
C     GTTMR = GRF(TPREV,Y,YPOUT,KROOTO,RPAR,IPAR)
      IREVCM = 11
      IPATH = 10
      TWANT = TPREV
      KWANT = KROOTO
      RETURN
 3120 CONTINUE
      GTTMR = GWANT
      IREVCM = 0
      GO TO 3180
C
 3140 IF ( .NOT. ROOT) GO TO 4140
C
C     A ROOT HAS BEEN ISOLATED. NOW BEGIN A REFINED ROOT FINDING
C     PROCEDURE ON THE INTERVAL (TPREV,TZERO) TO LOCATE THE ROOT AS
C     ACCURATELY AS POSSIBLE.
C
 3160 TZERO = TROOT
      TPREV = TLEFT
      KROOTO = 0
      MROOT = .FALSE.
C
C                                  SET UP TOLERANCES FOR THE ROOT FINDER
 3180 REZ = FOURU
      AEZ = 0.D0
      DEZU34 = U34
      KOUNT = 0
      IGA = 0
      TINT = MIN(ABS(TPREV),ABS(TZERO))
      IF (TINT.NE.0.D0) GO TO 3200
      TINT = MAX(ABS(TPREV),ABS(TZERO))
      GO TO 3220
 3200 IF (SIGN(1.D0,TPREV).EQ.SIGN(1.D0,TZERO)) GO TO 3240
 3220 AEZ = U*SRU*TINT
C
C                                  SIFT THROUGH ALL THE EQUATIONS IN
C                                  MAKING A FURTHER ATTEMPT TO LOCATE A
C                                  ROOT NEARER TO TPREV. (PICK EQUATION
C                                  HAVING SECANT ROOT NEAREST TO TLEFT.)
C
 3240 CALL RINTRP(TZERO,Y,YPOUT,NEQ,X,YY,R,R2D)
      TSTEP = TZERO - TPREV
      T = TZERO
      INROTP = INROOT
      KROOTP = KROOT
      KROOT = 0
C
 3260 ROOTS = .FALSE.
      TSAVE = T
      KROOTN = 0
      DELTGM = 0.D0
C     DO 1430 K=1,NEQG
      K = 1
 3280 CONTINUE
      TK = TKT(K)
      IF (DELSGN*(TK-T).GT.0.D0) GO TO 3340
      IF (IGSC(K).EQ.2) IGSC(K) = 0
C       GT = GRF(T,Y,YPOUT,K,RPAR,IPAR)
      IREVCM = 11
      IPATH = 11
      KWANT = K
      TWANT = T
      RETURN
 3300 CONTINUE
      GT = GWANT
      IREVCM = 0
      GP(K) = GT
      IF (ABS(GT).GT.ZERO) GO TO 3320
      ROOTS = .TRUE.
      KROOT = K
      GRES = GT
      IF (IGSC(K).EQ.0) IGSC(K) = 2
      GO TO 3340
 3320 IF (SIGN(1.D0,GOLD(K)).EQ.SIGN(1.D0,GT)) GO TO 3340
      IGSC(K) = 1
      IF (GT.LT.0.D0) IGSC(K) = -1
      DELTG = ABS(GT*(T-TK)/(GT-GOLD(K)))
      IF (DELTG.LE.DELTGM) GO TO 3340
      MROOT = .FALSE.
      KROOTN = K
      DELTGM = DELTG
C     1430 CONTINUE
 3340 K = K + 1
      IF (K.LE.NEQG) GO TO 3280
C
      IF (KROOTN.GT.0) GO TO 3440
      IF (MROOT) GO TO 3380
      DO 3360 K = 1, NEQG
         IF (DELSGN*(TKT(K)-T).GE.0.D0) GO TO 3360
         TKT(K) = T
         GOLD(K) = GP(K)
 3360 CONTINUE
 3380 IF ( .NOT. ROOTS) GO TO 3420
      ROOT = .TRUE.
      TROOTS = T
      INROOT = 2
      IF (ABS(IGSC(KROOT)).EQ.1) INROOT = 1
      IGA = 1
      DO 3400 K = 1, NEQG
         IF (DELSGN*(TKT(K)-T).GE.0.D0) GO TO 3400
         TKT(K) = T
         GOLD(K) = GP(K)
 3400 CONTINUE
      GO TO 3680
 3420 IF (KROOTO.EQ.0 .OR. KROOT.GT.0) GO TO 3480
      KROOTN = KROOTO
 3440 IF (KROOTN.EQ.KROOT) GO TO 3480
C
C                                    INITIALIZE FIRST CALL TO D02QFT
C                                      (FOR KROOT-TH EVENT EQUATION)
      IZFLAG = 0
      KROOT = KROOTN
      IF (MROOT) GO TO 3460
      TT = TKT(KROOT)
      GTT = GOLD(KROOT)
      GO TO 3480
 3460 TT = TPREV
      GTT = GTTMR
      GOLDSV = GP(KROOT)
C
 3480 GT = GP(KROOT)
C
C                                    CALL ROOTFINDER WITH REVERSE
C                                    COMMUNICATION APPROACH OF
C                                    SUPPLYING GT VALUES
C
 3500 AT = TT
      GAT = GTT
      GCT = GTS
C     CALL DEZERO(TT,GTT,T,GT,REZ,AEZ,IZFLAG)
      CALL D02QFT(TT,GTT,T,GT,REZ,AEZ,IZFLAG)
C
      IF (IZFLAG.GT.0) GO TO 3560
C
      CALL RINTRP(T,Y,YPOUT,NEQ,X,YY,R,R2D)
C
C                                AFTER THE SEARCH INTERVAL HAS COLLAPSED
C                                SUFFICIENTLY, WE NO LONGER EXAMINE THE
C                                REMAINING EVENT EQUATIONS.
C
      FAC = SRU
      IF (SEARCH) FAC = 0.1D0
      IF (ABS(TT-TS).GT.FAC*ABS(TSTEP)) GO TO 3260
C     GT = GRF(T,Y,YPOUT,KROOT,RPAR,IPAR)
      IREVCM = 11
      IPATH = 12
      KWANT = KROOT
      TWANT = T
      RETURN
 3520 CONTINUE
      GT = GWANT
      IREVCM = 0
      IF (ABS(GT).GT.ZERO) GO TO 3540
      IF (ABS(IGSC(KROOT)).NE.1) IGSC(KROOT) = 2
      GO TO 3500
 3540 IF (SIGN(1.D0,GOLD(KROOT)).EQ.SIGN(1.D0,GT)) GO TO 3500
      IGSC(KROOT) = 1
      IF (GT.LT.0.D0) IGSC(KROOT) = -1
      GO TO 3500
C
 3560 IF (IZFLAG.LE.3) GO TO 3660
C
C                                 PROCESS HAS NOT CONVERGED TO A ROOT
C
      ROOTS = .FALSE.
      IF (IZFLAG.EQ.4) GO TO 3580
      CALL RINTRP(T,Y,YPOUT,NEQ,X,YY,R,R2D)
      ROOT = .FALSE.
      RETURN
C
 3580 IF (TZERO.EQ.TROOT) GO TO 4140
C
C                                 ROOT OF EVEN MULTIPLICITY NOT FOUND.
C                                 NOW EXAMINE THE REST OF THE INTERVAL.
      TKT(KROOT) = TZERO
      GOLD(KROOT) = GOLDSV
      NEEDGK(KROOT) = 0
      MMR = MMR + 1
      IF (MMR.LE.MMRIN) GO TO 3100
      MROOT = .FALSE.
      IF (ROOT) GO TO 3160
C
      NEEDG = .TRUE.
      KROOT = 0
      TLEFT = TLBMR(1)
      T = TLEFT
      DO 3640 K = 1, NEQG
         DO 3600 J = 1, MMRIN
            IF (K.EQ.MMREQ(J)) GO TO 3620
 3600    CONTINUE
         GO TO 3640
 3620    TKT(K) = TSAVE
         GOLD(K) = GP(K)
 3640 CONTINUE
      GO TO 80
C
C                                 ROOT HAS BEEN FOUND.
C                                 UPDATE RESIDUALS AND OBTAIN ADDITIONAL
C                                 ROOT INFORMATION FOR ALL EVENT
C                                 EQUATIONS.  WE WILL NOT REPORT A ROOT
C                                 WHICH APPEARS TO ARISE FROM NOISY
C                                 EVALUATIONS OF AN EVENT FUNCTION IF IT
C                                 IS TOO CLOSE TO A PREVIOUSLY REPORTED
C                                 ROOT.
C
 3660 ROOT = .TRUE.
      ROOTS = .TRUE.
      TROOTS = T
      GRES = GT
      GOLD(KROOT) = GRES
      GP(KROOT) = GRES
      INROOT = 1
      IF (IZFLAG.EQ.3) INROOT = 2
      IF (IZFLAG.EQ.2 .AND. ABS(IGSC(KROOT)).NE.1) INROOT = 2
 3680 IF (INROOT.EQ.1 .AND. KOUNT.GT.25) INROOT = 3
      IF (INROOT.EQ.2) IGSC(KROOT) = 2
C
      IF (IGA.EQ.1) GO TO 3820
      ISIN = 0
C     DO 1570 K=1,NEQG
      K = 1
 3700 CONTINUE
      IF (DELSGN*(TKT(K)-T).GE.0.D0) GO TO 3800
      TKT(K) = T
      IF (K.EQ.KROOT) GO TO 3800
      IF (ISIN.EQ.1) GO TO 3720
      CALL RINTRP(T,Y,YPOUT,NEQ,X,YY,R,R2D)
      ISIN = 1
C     1555   GOT = GRF(T,Y,YPOUT,K,RPAR,IPAR)
 3720 IREVCM = 11
      IPATH = 13
      KWANT = K
      TWANT = T
      RETURN
 3740 CONTINUE
      GOT = GWANT
      IREVCM = 0
      IF (IGSC(K).EQ.2) IGSC(K) = 0
      IF (ABS(GOT).GT.ZERO) GO TO 3760
      IF (ABS(IGSC(K)).NE.1) IGSC(K) = 2
      GO TO 3780
 3760 IF (SIGN(1.D0,GOT).EQ.SIGN(1.D0,GOLD(K))) GO TO 3780
      IGSC(K) = 3
      IF (GOT.LT.0.D0) IGSC(K) = -3
 3780 GOLD(K) = GOT
      GP(K) = GOT
C     1570 CONTINUE
 3800 K = K + 1
      IF (K.LE.NEQG) GO TO 3700
C
 3820 DO 3840 K = 1, NEQG
         IF (IGSC(K).NE.0 .AND. IGSC(K).NE.2) GO TO 3860
 3840 CONTINUE
      GO TO 4060
 3860 GRIGHT = GCT
      IF (SIGN(1.D0,AT-T).EQ.DELSGN) GRIGHT = GAT
      SIGNG = -SIGN(1.D0,GRIGHT)
      PU = -U78
C     DO 1615 JR=1,2
      JR = 1
 3880 CONTINUE
      SIGNG = -SIGNG
      PU = -PU
      ROOTNO = T + DELSGN*PU*ABS(T)
      IF (DELSGN*(ROOTNO-X).GT.0.D0) GO TO 4040
      IF (DELSGN*(ROOTNO-TLEFT).LT.0.D0) GO TO 4040
      CALL RINTRP(ROOTNO,Y,YPOUT,NEQ,X,YY,R,R2D)
C       DO 1610 K=1,NEQG
      K = 1
 3900 CONTINUE
      IF (ABS(IGSC(K)).EQ.1) GO TO 3920
      IF (ABS(IGSC(K)).EQ.3) IGSC(K) = IGSC(K)/3
      GO TO 4020
 3920 IF (K.EQ.KROOT) GO TO 3940
      IF (JR.EQ.2) GO TO 4020
      IF (DELSGN*(TKT(K)-ROOTNO).GE.0.D0) GO TO 3980
      IF (ABS(GOLD(K)).LE.ZERO) GO TO 4020
C     1595     GRNO = GRF(ROOTNO,Y,YPOUT,K,RPAR,IPAR)
 3940 IREVCM = 11
      IPATH = 14
      KWANT = K
      TWANT = ROOTNO
      RETURN
 3960 CONTINUE
      GRNO = GWANT
      IREVCM = 0
      IF (JR.EQ.1) GP(K) = GRNO
      IF (JR.EQ.1) TKT(K) = ROOTNO
      IF (K.EQ.KROOT) GO TO 4000
      IF (ABS(GRNO).LE.ZERO) GO TO 4020
      IF (SIGN(1.D0,GRNO).NE.SIGN(1.D0,GOLD(K))) GO TO 4020
 3980 IGSC(K) = 0
      GO TO 4020
 4000 IF (ABS(GRNO).LE.ZERO) INROOT = 4
      IF (SIGN(1.D0,GRNO).NE.SIGNG) INROOT = 4
      IF (JR.EQ.1 .AND. ABS(GRNO).LE.(1.D0+FOURU)*ABS(GRES)) INROOT = 4
C     1610   CONTINUE
 4020 K = K + 1
      IF (K.LE.NEQG) GO TO 3900
      IF (INROOT.EQ.4) GO TO 4060
C     1615 CONTINUE
 4040 JR = JR + 1
      IF (JR.LE.2) GO TO 3880
C
 4060 IF (INROOT.EQ.4 .AND. ABS(PROOT(KROOT)-T).LT.U34*ABS(T)) GO TO 80
      CALL RINTRP(T,Y,YPOUT,NEQ,X,YY,R,R2D)
C
      DO 4120 K = 1, NEQG
         IF (IGSC(K).EQ.0) GO TO 4100
         IF ( .NOT. SEARCH) GO TO 4080
         IF (PROOT(K).NE.SRBIG) ROOTD(K) = ABS(PROOT(K)-T)
         IF (ABS(ROOTD(K)).LT.2.D0*SRU*ABS(T)) ROOTD(K) = SRBIG
         IF (K.EQ.KROOT .AND. INROOT.EQ.4) ROOTD(KROOT) = -ROOTD(KROOT)
 4080    PROOT(K) = T
         GO TO 4120
 4100    IF ( .NOT. SEARCH) GO TO 4120
         IF (ABS(ROOTD(K)).EQ.SRBIG) GO TO 4120
         IF (ABS(PROOT(K)-T).LT.2.D0*ABS(ROOTD(K))) GO TO 4120
         PROOT(K) = SRBIG
         ROOTD(K) = SRBIG
 4120 CONTINUE
      RETURN
C
C     ..................................................................
C
C                                 NO ROOT FOUND IN THE SEARCH INTERVAL.
C                                 STORE VALUES FOR USE ON THE NEXT STEP.
C
 4140 DO 4160 K = 1, NEQG
         IF (DELSGN*(TKT(K)-TNEW).GE.0.D0) GO TO 4160
         GOLD(K) = GNEW(K)
         TKT(K) = TNEW
         IF ( .NOT. SEARCH) GO TO 4160
         IF (ABS(ROOTD(K)).EQ.SRBIG) GO TO 4160
         IF (ABS(PROOT(K)-TNEW).LT.2.D0*ABS(ROOTD(K))) GO TO 4160
         PROOT(K) = SRBIG
         ROOTD(K) = SRBIG
 4160 CONTINUE
      INROTP = INROOT
      KROOTP = KROOT
      KROOT = 0
C
      RETURN
C
C
C     END OF D02QFV (RDEZ)
C
C
      END
      SUBROUTINE D02QFW(NEQG,KROOT,INROOT,TKT,GOLD,PROOT,ROOTD,GP,
     *                  NEEDGK,IGSC,T)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C
C
C     DATE WRITTEN   840908   (YYMMDD)
C     REVISION DATE  850101   (YYMMDD)
C     AUTHOR  WATTS, H. A., (SNLA)
C
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  T
      INTEGER           INROOT, KROOT, NEQG
C     .. Array Arguments ..
      DOUBLE PRECISION  GOLD(NEQG), GP(NEQG), PROOT(NEQG), ROOTD(NEQG),
     *                  TKT(NEQG)
      INTEGER           IGSC(NEQG), NEEDGK(NEQG)
C     .. Scalars in Common ..
      DOUBLE PRECISION  DELSGN, FOURU, SRBIG, SRU, SVTNEW, TLEFT,
     *                  TROOTS, U, U34, U78, ZERO
      INTEGER           INROTP, KROOTP
      LOGICAL           DISCOP, GSTOP, NEEDG, NEWGEQ, PGSTOP, PSERCH,
     *                  ROOT, ROOTS, SEARCH
C     .. Local Scalars ..
      INTEGER           K
C     .. Intrinsic Functions ..
      INTRINSIC         ABS
C     .. Common blocks ..
      COMMON            /BD02QF/ZERO, U, FOURU, SRU, U34, U78, SRBIG,
     *                  DELSGN, TROOTS, TLEFT, SVTNEW, KROOTP, INROTP,
     *                  GSTOP, PGSTOP, ROOT, ROOTS, NEEDG, DISCOP,
     *                  NEWGEQ, SEARCH, PSERCH
C     .. Save statement ..
      SAVE              /BD02QF/
C     .. Executable Statements ..
C
C                       -- INITIALIZATION AT THE VERY BEGINNING OF THE
C                          ROOT SEARCHING PROCESS AND WHENEVER THE ROOT
C                          FUNCTIONS HAVE BEEN ALTERED
C                       -- EVALUATE GRF AND CHECK FOR A ROOT
C
      NEEDG = .TRUE.
      ROOT = .FALSE.
      ROOTS = .FALSE.
      KROOT = 0
      KROOTP = 0
      INROOT = 1
      INROTP = 0
      TLEFT = T
      SVTNEW = T
      DO 40 K = 1, NEQG
         TKT(K) = T
         IGSC(K) = 0
         PROOT(K) = SRBIG
         IF ( .NOT. SEARCH) GO TO 20
         ROOTD(K) = SRBIG
         NEEDGK(K) = 0
C        10   GOLD(K) = GRF(T,Y,YPOUT,K,RPAR,IPAR)
   20    GP(K) = GOLD(K)
         IF (ABS(GOLD(K)).GT.ZERO) GO TO 40
         ROOT = .TRUE.
         ROOTS = .TRUE.
         TROOTS = T
         KROOT = K
         IGSC(K) = 2
         PROOT(K) = T
   40 CONTINUE
      RETURN
C
C
C     END OF D02QFW (RDEI)
C
C
      END
      SUBROUTINE D02QFX(IREVCM,TWANT,KWANT,GWANT,NEQ,T,Y,TOUT,RTOL,ATOL,
     *                  IDID,YPOUT,YP,YY,WT,P,PHI,GOLD,GNEW,TGV,GV,GP,
     *                  TKT,TLBMR,TRBMR,PROOT,ROOTD,TSTOP,H,EPS,X,HMAX,
     *                  MAXNUM,NSUCC,NFAIL,INDXG,IGSC,MMREQ,NEEDGK,
     *                  KROOT,INROOT,NEQG,BADCMP)
C     MARK 13 RELEASE. NAG COPYRIGHT 1988.
C     MARK 15B REVISED. IER-948 (NOV 1991).
C
C
C     D02QFF/D02QGF MERELY ALLOCATE STORAGE FOR D02QFX TO RELIEVE THE
C     THE INCONVENIENCE OF A LONG CALL LIST.
C
C
C     .. Scalar Arguments ..
      DOUBLE PRECISION  EPS, GWANT, H, HMAX, T, TOUT, TSTOP, TWANT, X
      INTEGER           BADCMP, IDID, INROOT, IREVCM, KROOT, KWANT,
     *                  MAXNUM, NEQ, NEQG, NFAIL, NSUCC
C     .. Array Arguments ..
      DOUBLE PRECISION  ATOL(*), GNEW(NEQG), GOLD(NEQG), GP(NEQG),
     *                  GV(3,NEQG), P(NEQ), PHI(NEQ,16), PROOT(NEQG),
     *                  ROOTD(NEQG), RTOL(*), TGV(3,NEQG), TKT(NEQG),
     *                  TLBMR(NEQG), TRBMR(NEQG), WT(NEQ), Y(NEQ),
     *                  YP(NEQ), YPOUT(NEQ), YY(NEQ)
      INTEGER           IGSC(NEQG), INDXG(NEQG), MMREQ(NEQG),
     *                  NEEDGK(NEQG)
C     .. Scalars in Common ..
      DOUBLE PRECISION  DELSGN, FOURU, HOLD, SRBIG, SRU, SVTNEW, TLEFT,
     *                  TOLD, TROOTS, TSTAR, TWOU, U, U34, U78, XOLD,
     *                  XSAVE, ZERO
      INTEGER           IBEGIN, IINTEG, INFLOP, INIT, INROTP, IQUIT,
     *                  ITOL, ITSTOP, IVC, IZFLAG, KGI, KLE4, KOLD,
     *                  KORD, KPREV, KROOTP, KSTEPS, NS
      LOGICAL           CRASH, DISCOP, GSTOP, INTOUT, NEEDG, NEWGEQ,
     *                  NORND, PGSTOP, PHASE1, PSERCH, ROOT, ROOTS,
     *                  SEARCH, START, STIFF
C     .. Arrays in Common ..
      DOUBLE PRECISION  ALPHA(12), BETA(12), G(13), GI(11), PSI(12),
     *                  SIG(13), V(12), W(12)
      INTEGER           IV(10)
C     .. Local Scalars ..
      DOUBLE PRECISION  BIG, DT, HA, U14, U18
      INTEGER           L, LTOL
C     .. External Functions ..
      DOUBLE PRECISION  X02AJF, X02AMF
      EXTERNAL          X02AJF, X02AMF
C     .. External Subroutines ..
      EXTERNAL          D02QFQ, D02QFR, D02QFS, D02QFU, D02QFV, D02QFW
C     .. Intrinsic Functions ..
      INTRINSIC         ABS, MAX, MIN, SIGN, SQRT
C     .. Common blocks ..
      COMMON            /AD02QF/ALPHA, BETA, PSI, V, W, SIG, G, GI,
     *                  XOLD, HOLD, TOLD, XSAVE, TSTAR, TWOU, INIT,
     *                  IBEGIN, ITOL, IINTEG, ITSTOP, INFLOP, IQUIT, IV,
     *                  NS, KORD, KOLD, KSTEPS, KLE4, KPREV, IVC, KGI,
     *                  START, PHASE1, NORND, STIFF, INTOUT
      COMMON            /BD02QF/ZERO, U, FOURU, SRU, U34, U78, SRBIG,
     *                  DELSGN, TROOTS, TLEFT, SVTNEW, KROOTP, INROTP,
     *                  GSTOP, PGSTOP, ROOT, ROOTS, NEEDG, DISCOP,
     *                  NEWGEQ, SEARCH, PSERCH
      COMMON            /CD02QF/IZFLAG, CRASH
C     .. Save statement ..
      SAVE              /AD02QF/, /BD02QF/, /CD02QF/
C     .. Executable Statements ..
C
C     ..................................................................
C
C     THE EXPENSE OF SOLVING THE PROBLEM IS MONITORED BY COUNTING THE
C     NUMBER OF  STEPS ATTEMPTED. WHEN THIS EXCEEDS  MAXNUM, THE COUNTER
C     IS RESET TO ZERO AND THE USER IS INFORMED ABOUT POSSIBLE EXCESSIVE
C     WORK.
C
C      DATA           MAXNUM/500/    this is now 1000
C
C     ..................................................................
C
C
      GO TO (20,380,600,600,600,600,600,600,120,
     *       200,200,400) IREVCM
C
      IF (IBEGIN.EQ.1) GO TO 60
C
C     ON THE FIRST CALL , PERFORM INITIALIZATION --
C
C        DEFINE SOME MACHINE DEPENDENT QUANTITIES BY CALLING THE
C        FUNCTION ROUTINE  R1MACH. THE USER MUST MAKE SURE THAT THE
C        VALUES SET IN R1MACH ARE RELEVANT TO THE COMPUTER BEING USED.
C
C                       -- SET SMALLEST POSITIVE FLOATING POINT NUMBER
C      ZERO = R1MACH(1)
      ZERO = X02AMF()
C                       -- SET LARGEST POSITIVE FLOATING POINT NUMBER
C      BIG = R1MACH(2)
      BIG = 1.0D0/X02AMF()
C                       -- SET MACHINE UNIT ROUNDOFF VALUE
C      U = R1MACH(4)
      U = X02AJF()
C                       -- SET ASSOCIATED MACHINE DEPENDENT PARAMETERS
      TWOU = 2.D0*U
      FOURU = 4.D0*U
      U18 = U**0.125D0
      U14 = U18*U18
      SRU = U14*U14
      U34 = SRU*U14
      U78 = U34*U18
      SRBIG = SQRT(BIG)
C                       -- SET INITIALIZATION INDICATOR
      INIT = 1
C                       -- SET COUNTER FOR ATTEMPTED STEPS
      KSTEPS = 0
C                       -- SET INDICATOR FOR INTERMEDIATE-OUTPUT
      INTOUT = .FALSE.
C                       -- SET INDICATOR FOR STIFFNESS DETECTION
      STIFF = .FALSE.
C                       -- SET STEP COUNTER FOR STIFFNESS DETECTION
      KLE4 = 0
C                       -- SET INDICATORS FOR D02QFQ CODE
      START = .TRUE.
      PHASE1 = .TRUE.
      NORND = .TRUE.
C                       -- SET SOME INDEPENDENT VARIABLE VALUES
      TOLD = T
      X = T
      XOLD = X
C                       -- EVALUATE INITIAL DERIVATIVES
C
C     CALL F(T,Y,YPOUT,RPAR,IPAR)
      IREVCM = 1
      TWANT = T
      RETURN
   20 CONTINUE
      IREVCM = 0
C
C                       -- SET DEPENDENT VARIABLES AND DERIVATIVES
C                                   YY(*) AND YP(*) FOR D02QFQ
      DO 40 L = 1, NEQ
         YY(L) = Y(L)
         YP(L) = YPOUT(L)
   40 CONTINUE
C                                                      ************
C                       -- SET INDICATORS FOR USE WITH ROOT FINDING
C                                                      ************
      ROOT = .FALSE.
      PGSTOP = .FALSE.
      DISCOP = .FALSE.
      IF (IBEGIN.EQ.-1) DISCOP = .TRUE.
      PSERCH = .FALSE.
C                                                      ************
C                                                      ************
C
C                       -- RESET IBEGIN FOR SUBSEQUENT CALLS
      IBEGIN = 1
C
C     ..................................................................
C
C     DEFAULT TOLERANCES WERE PREVIOUSLY SET HERE.
C     THIS IS NOW HANDLED BY SETUP ROUTINE D02QWF.
C
C
   60 CONTINUE
C
C
      IF (IDID.NE.(-2)) GO TO 80
C
C
      IBEGIN = -13
      RETURN
C
C     ..................................................................
C                                    ***********************************
C                                    * INITIALIZATION FOR ROOT FINDING *
C                                    ***********************************
C
   80 IF ( .NOT. GSTOP) GO TO 140
      IF (DISCOP) GO TO 140
      IF (NEWGEQ) GO TO 100
      IF (SEARCH .AND. .NOT. PSERCH) GO TO 100
      IF (PGSTOP) GO TO 140
C     70 CALL RDEI(GRF,NEQG,KROOT,INROOT,TKT,GOLD,PROOT,ROOTD,GP,NEEDGK,
C     1          IGSC,T,Y,YPOUT,RPAR,IPAR)
  100 CONTINUE
      TWANT = T
      IREVCM = 9
      RETURN
  120 CONTINUE
      IREVCM = 0
C     CALL RDEI(NEQG,KROOT,INROOT,TKT,GOLD,PROOT,ROOTD,GP,NEEDGK,IGSC,T)
      CALL D02QFW(NEQG,KROOT,INROOT,TKT,GOLD,PROOT,ROOTD,GP,NEEDGK,IGSC,
     *            T)
      IF ( .NOT. ROOT) GO TO 140
      IDID = 4
      IF (T.EQ.TOUT) IDID = 5
      PGSTOP = GSTOP
      PSERCH = SEARCH
      RETURN
  140 PGSTOP = GSTOP
      PSERCH = SEARCH
C                                    ***********************************
C                                    ***********************************
C
C                         -- RETURN IF TOUT=T INITIALLY
      IF (T.NE.TOUT) GO TO 160
      IDID = 2
      RETURN
C
C     ..................................................................
C
C     BRANCH ON STATUS OF INITIALIZATION INDICATOR
C            INIT=1 MEANS NOMINAL STEP SIZE AND DIRECTION NOT YET SET
C            INIT=2 MEANS NO FURTHER INITIALIZATION REQUIRED
C
  160 IF (INIT.EQ.2) GO TO 180
C
C     ..................................................................
C
C     MORE INITIALIZATION --
C
      INIT = 2
C                         -- SET SIGN OF INTEGRATION DIRECTION
      DELSGN = SIGN(1.0D0,TOUT-T)
C
C                         -- DEFINE A MAXIMUM STEP SIZE FOR D02QFQ CODE
C
      H = SIGN(MAX(FOURU*ABS(X),ABS(TOUT-X)),TOUT-X)
C
C     ..................................................................
C
C     PLACE OF RETURN FOR STEP BY STEP LOOPING
C
C                     **************************************************
C                     * MAJOR BLOCK OF CODE FOR ROOT FINDING PROCEDURE *
C                     **************************************************
C
  180 IF ( .NOT. GSTOP .OR. T.EQ.X) GO TO 280
C
  200 CONTINUE
C     CALL RDEZ(IREVCM,TWANT,KWANT,GWANT,NEQ,T,Y,YPOUT,TOUT,X,YY,P,PHI,
C     *          RINTAM,NEQG,GOLD,GNEW,GP,TGV,GV,TKT,TLBMR,TRBMR,PROOT,
C     *          ROOTD,MMREQ,INDXG,IGSC,NEEDGK,KROOT,INROOT,IZFLAG)
      CALL D02QFV(IREVCM,TWANT,KWANT,GWANT,NEQ,T,Y,YPOUT,TOUT,X,YY,P,
     *            PHI,D02QFS,NEQG,GOLD,GNEW,GP,TGV,GV,TKT,TLBMR,TRBMR,
     *            PROOT,ROOTD,MMREQ,INDXG,IGSC,NEEDGK,KROOT,INROOT,
     *            IZFLAG)
      IF (IREVCM.NE.0) RETURN
C
      IF (ROOT) GO TO 220
      IF (IZFLAG.EQ.5) GO TO 260
      GO TO 280
C                                 ROOT FOUND
  220 IDID = 4
      IF (T.NE.TOUT) GO TO 240
      IDID = 5
      IF (T.NE.X) IDID = 6
  240 IF (IINTEG.EQ.1 .AND. T.EQ.X) INTOUT = .FALSE.
      TOLD = T
      RETURN
C                                 SINGULARITY IN EVENT FUNCTION
  260 IDID = -8
      IBEGIN = -13
      TOLD = T
      RETURN
C                     **************************************************
C                     **************************************************
C
C                                 IF ALREADY PAST OUTPUT POINT,
C                                   INTERPOLATE AND RETURN
C
  280 IF ((X-TOUT)*DELSGN.LT.0.D0) GO TO 300
C
C     CALL SINTRP(X,YY,TOUT,Y,YPOUT,NEQ,KOLD,PHI,IVC,IV,KGI,GI,ALPHA,G,
C     *            W,XOLD,P)
C     CALL SINTRP(X,YY,TOUT,Y,YPOUT,NEQ,NEQ,KOLD,PHI,IVC,IV,KGI,GI,
C     *            ALPHA,G,W,XOLD,P)
      CALL D02QFR(X,YY,TOUT,Y,YPOUT,NEQ,NEQ,KOLD,PHI,IVC,IV,KGI,GI,
     *            ALPHA,G,W,XOLD,P)
      IDID = 3
      IF (X.EQ.TOUT) IDID = 2
      T = TOUT
      TOLD = T
      IF (IDID.EQ.2) INTOUT = .FALSE.
      RETURN
C
C                                 IF IN THE INTERMEDIATE-OUTPUT MODE
C                                 AND HAVE NOT YET REPORTED THE SOLUTION
C                                 AT THE END OF THE STEP, RETURN
C
  300 IF (IINTEG.EQ.0 .OR. .NOT. INTOUT) GO TO 340
C
      IDID = 1
      DO 320 L = 1, NEQ
         Y(L) = YY(L)
         YPOUT(L) = YP(L)
  320 CONTINUE
      T = X
      TOLD = T
      INTOUT = .FALSE.
      RETURN
C
C                                 IF CANNOT GO PAST TSTOP AND
C                                 SUFFICIENTLY CLOSE, EXTRAPOLATE
C                                 AND RETURN
C
  340 IF (ITSTOP.NE.1) GO TO 420
      IF (ABS(TSTOP-X).GE.FOURU*ABS(X)) GO TO 420
C
      DT = TOUT - X
      DO 360 L = 1, NEQ
         Y(L) = YY(L) + DT*YP(L)
  360 CONTINUE
C     CALL F(TOUT,Y,YPOUT,RPAR,IPAR)
      IREVCM = 2
      TWANT = TOUT
      RETURN
  380 CONTINUE
      IREVCM = 0
      IDID = 3
      T = TOUT
      TOLD = T
C
C                                ***************************************
C                                * LAST BLOCK OF CODE FOR ROOT FINDING *
C                                ***************************************
      IF ( .NOT. GSTOP) RETURN
C     CALL RDEO(GRF,NEQG,KROOT,INROOT,GOLD,PROOT,ROOTD,GP,IGSC,
C     1          TOUT,Y,YPOUT,RPAR,IPAR)
      TWANT = TOUT
  400 CONTINUE
C     CALL RDEO(IREVCM,KWANT,GWANT,NEQG,KROOT,INROOT,GOLD,PROOT,ROOTD,
C     *          GP,IGSC,TOUT)
      CALL D02QFU(IREVCM,KWANT,GWANT,NEQG,KROOT,INROOT,GOLD,PROOT,ROOTD,
     *            GP,IGSC,TOUT)
      IF (IREVCM.EQ.12) RETURN
      IF (ROOT) IDID = 6
      RETURN
C                                 **************************************
C                                 **************************************
C
C     ..................................................................
C
C                                 MONITOR NUMBER OF STEPS ATTEMPTED
C
  420 IF (KSTEPS.LE.MAXNUM) GO TO 480
C
C                                 A SIGNIFICANT AMOUNT OF WORK HAS BEEN
C                                 EXPENDED
      IDID = -1
      KSTEPS = 0
      IF ( .NOT. STIFF) GO TO 440
C
C                                 PROBLEM APPEARS TO BE STIFF
      IDID = -4
      STIFF = .FALSE.
      KLE4 = 0
C
  440 DO 460 L = 1, NEQ
         Y(L) = YY(L)
         YPOUT(L) = YP(L)
  460 CONTINUE
      T = X
      TOLD = T
      IBEGIN = -13
      RETURN
C
C     ..................................................................
C
C                                 LIMIT STEP SIZE, SET WEIGHT VECTOR
C                                 AND TAKE A STEP
C
  480 HA = ABS(H)
      IF (ITSTOP.NE.1) GO TO 500
      HA = MIN(HA,ABS(TSTOP-X))
      IF (HMAX.NE.0.0D0) HA = MIN(HA,ABS(HMAX))
  500 H = SIGN(HA,H)
      EPS = 1.0D0
      LTOL = 1
      DO 520 L = 1, NEQ
         IF (ITOL.EQ.1) LTOL = L
         WT(L) = RTOL(LTOL)*ABS(YY(L)) + ATOL(LTOL)
         IF (WT(L).LE.ZERO) GO TO 540
  520 CONTINUE
      GO TO 580
C
C                                 RELATIVE ERROR CRITERION INAPPROPRIATE
  540 IDID = -3
      BADCMP = L
      DO 560 L = 1, NEQ
         Y(L) = YY(L)
         YPOUT(L) = YP(L)
  560 CONTINUE
      T = X
      TOLD = T
      IBEGIN = -13
      RETURN
C
C                                 CALL THE SINGLE STEP INTEGRATOR
  580 T = X
C
C     CALL STEPS(IREVCM,TWANT,NEQ,YY,X,H,EPS,WT,START,HOLD,KORD,KOLD,
C                CRASH,PHI,P,YP,PSI,ALPHA,BETA,SIG,V,W,G,PHASE1,NS,
C                NORND,KSTEPS,TWOU,FOURU,XOLD,KPREV,IVC,IV,KGI,GI,
C                NSUCC,NFAIL)
  600 CALL D02QFQ(IREVCM,TWANT,NEQ,YY,X,H,EPS,WT,START,HOLD,KORD,KOLD,
     *            CRASH,PHI,P,YP,PSI,ALPHA,BETA,SIG,V,W,G,PHASE1,NS,
     *            NORND,KSTEPS,TWOU,FOURU,XOLD,KPREV,IVC,IV,KGI,GI,
     *            NSUCC,NFAIL)
      IF (IREVCM.NE.0) RETURN
C
C
C     ..................................................................
C
      IF ( .NOT. CRASH) GO TO 640
C
C                                 TOLERANCES TOO SMALL
      IDID = -2
C
C
C     TOLERANCES PREVIOUSLY SCALED BY 'EPS' HERE.
C     THIS IS NOW THE USER'S RESPONSIBILITY.
C
C
      DO 620 L = 1, NEQ
         Y(L) = YY(L)
         YPOUT(L) = YP(L)
  620 CONTINUE
      T = X
      TOLD = T
      IBEGIN = -13
      RETURN
C
C                                 (STIFFNESS TEST) COUNT NUMBER OF
C                                 CONSECUTIVE STEPS TAKEN WITH THE ORDER
C                                 OF THE METHOD BEING LESS OR EQUAL TO
C                                 FOUR
C
  640 KLE4 = KLE4 + 1
      IF (KOLD.GT.4) KLE4 = 0
      IF (KLE4.GE.50) STIFF = .TRUE.
      INTOUT = .TRUE.
      GO TO 180
C
C
C     END OF D02QFX (RDE)
C
C
      END
      SUBROUTINE E04UDU(STRING)
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     PURPOSE:  This subroutine changes all lower case letters in the
C               character string to upper case.
C
C     METHOD:   Each character in STRING is treated in turn.  The
C               intrinsic function INDEX effectively allows a table
C               lookup, with the local strings LOW and UPP acting as
C               two tables. This method avoids the use of CHAR and
C               ICHAR, which appear be different on ASCII and EBCDIC
C               machines.
C
C     ARGUMENTS
C     ARG       DIM     TYPE I/O/S DESCRIPTION
C     STRING       *       C   I/O   Character string possibly
C                                   containing some lower-case
C                                   letters  on input; strictly
C                                   upper-case letters on output
C                                   with no change to any
C                                   non-alphabetic characters.
C
C     EXTERNAL REFERENCES:
C     LEN    - Returns the declared length of a CHARACTER variable.
C     INDEX  - Returns the position of second string within first.
C
C     ENVIRONMENT:  ANSI FORTRAN 77
C
C     DEVELOPMENT HISTORY:
C     DATE  INITIALS  DESCRIPTION
C     06/28/83   CLH    Initial design.
C     01/03/84   RAK    Eliminated NCHAR input.
C     06/14/84   RAK    Used integer PARAMETERs in comparison.
C     04/21/85   RAK    Eliminated DO/END DO in favor of standard code.
C     09/10/85   MAS    Eliminated CHAR,ICHAR in favor of LOW, UPP,
C                       INDEX.
C
C     AUTHOR: Charles Hooper, Informatics General, Palo Alto, CA.
C
C-----------------------------------------------------------------------
C
C     .. Scalar Arguments ..
      CHARACTER*(*)     STRING
C     .. Local Scalars ..
      INTEGER           I, J
      CHARACTER*1       C
      CHARACTER*26      LOW, UPP
C     .. Intrinsic Functions ..
      INTRINSIC         INDEX, LEN, LGE, LLE
C     .. Data statements ..
      DATA              LOW/'abcdefghijklmnopqrstuvwxyz'/,
     *                  UPP/'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
C     .. Executable Statements ..
C
      DO 20 J = 1, LEN(STRING)
         C = STRING(J:J)
         IF (LGE(C,'a') .AND. LLE(C,'z')) THEN
C           IF (C.GE.'a' .AND. C.LE.'z') THEN
            I = INDEX(LOW,C)
            IF (I.GT.0) STRING(J:J) = UPP(I:I)
         END IF
   20 CONTINUE
      RETURN
C
C     End of  E04UDU. (OPUPPR)
C
      END
      INTEGER FUNCTION P01ABF(IFAIL,IERROR,SRNAME,NREC,REC)
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C     MARK 13 REVISED. IER-621 (APR 1988).
C     MARK 13B REVISED. IER-668 (AUG 1988).
C
C     P01ABF is the error-handling routine for the NAG Library.
C
C     P01ABF either returns the value of IERROR through the routine
C     name (soft failure), or terminates execution of the program
C     (hard failure). Diagnostic messages may be output.
C
C     If IERROR = 0 (successful exit from the calling routine),
C     the value 0 is returned through the routine name, and no
C     message is output
C
C     If IERROR is non-zero (abnormal exit from the calling routine),
C     the action taken depends on the value of IFAIL.
C
C     IFAIL =  1: soft failure, silent exit (i.e. no messages are
C                 output)
C     IFAIL = -1: soft failure, noisy exit (i.e. messages are output)
C     IFAIL =-13: soft failure, noisy exit but standard messages from
C                 P01ABF are suppressed
C     IFAIL =  0: hard failure, noisy exit
C
C     For compatibility with certain routines included before Mark 12
C     P01ABF also allows an alternative specification of IFAIL in which
C     it is regarded as a decimal integer with least significant digits
C     cba. Then
C
C     a = 0: hard failure  a = 1: soft failure
C     b = 0: silent exit   b = 1: noisy exit
C
C     except that hard failure now always implies a noisy exit.
C
C     S.Hammarling, M.P.Hooper and J.J.du Croz, NAG Central Office.
C
C     .. Scalar Arguments ..
      INTEGER                 IERROR, IFAIL, NREC
      CHARACTER*(*)           SRNAME
C     .. Array Arguments ..
      CHARACTER*(*)           REC(*)
C     .. Local Scalars ..
      INTEGER                 I, NERR
      CHARACTER*72            MESS
C     .. External Subroutines ..
      EXTERNAL                P01ABZ, X04AAF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC               ABS, MOD
C     .. Executable Statements ..
      IF (IERROR.NE.0) THEN
C        Abnormal exit from calling routine
         IF (IFAIL.EQ.-1 .OR. IFAIL.EQ.0 .OR. IFAIL.EQ.-13 .OR.
     *       (IFAIL.GT.0 .AND. MOD(IFAIL/10,10).NE.0)) THEN
C           Noisy exit
            CALL X04AAF(0,NERR)
            DO 20 I = 1, NREC
               CALL X04BAF(NERR,REC(I))
   20       CONTINUE
            IF (IFAIL.NE.-13) THEN
               WRITE (MESS,FMT=99999) SRNAME, IERROR
               CALL X04BAF(NERR,MESS)
               IF (ABS(MOD(IFAIL,10)).NE.1) THEN
C                 Hard failure
                  CALL X04BAF(NERR,
     *                     ' ** NAG hard failure - execution terminated'
     *                        )
                  CALL P01ABZ
               ELSE
C                 Soft failure
                  CALL X04BAF(NERR,
     *                        ' ** NAG soft failure - control returned')
               END IF
            END IF
         END IF
      END IF
      P01ABF = IERROR
      RETURN
C
99999 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A,': IFAIL',
     *  ' =',I6)
      END
      SUBROUTINE P01ABZ
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C
C     Terminates execution when a hard failure occurs.
C
C     ******************** IMPLEMENTATION NOTE ********************
C     The following STOP statement may be replaced by a call to an
C     implementation-dependent routine to display a message and/or
C     to abort the program.
C     *************************************************************
C     .. Executable Statements ..
      STOP
      END
      INTEGER FUNCTION P01ACF(IFAIL,IERROR,SRNAME,VARBNM,NREC,REC)
C     MARK 15 RELEASE. NAG COPYRIGHT 1991.
C
C     P01ACF is the error-handling routine for the F06 AND F07
C     Chapters of the NAG Fortran Library. It is a slightly modified
C     version of P01ABF.
C
C     P01ACF either returns the value of IERROR through the routine
C     name (soft failure), or terminates execution of the program
C     (hard failure). Diagnostic messages may be output.
C
C     If IERROR = 0 (successful exit from the calling routine),
C     the value 0 is returned through the routine name, and no
C     message is output
C
C     If IERROR is non-zero (abnormal exit from the calling routine),
C     the action taken depends on the value of IFAIL.
C
C     IFAIL =  1: soft failure, silent exit (i.e. no messages are
C                 output)
C     IFAIL = -1: soft failure, noisy exit (i.e. messages are output)
C     IFAIL =-13: soft failure, noisy exit but standard messages from
C                 P01ACF are suppressed
C     IFAIL =  0: hard failure, noisy exit
C
C     For compatibility with certain routines included before Mark 12
C     P01ACF also allows an alternative specification of IFAIL in which
C     it is regarded as a decimal integer with least significant digits
C     cba. Then
C
C     a = 0: hard failure  a = 1: soft failure
C     b = 0: silent exit   b = 1: noisy exit
C
C     except that hard failure now always implies a noisy exit.
C
C     S.Hammarling, M.P.Hooper and J.J.du Croz, NAG Central Office.
C
C     .. Scalar Arguments ..
      INTEGER                 IERROR, IFAIL, NREC
      CHARACTER*(*)           SRNAME, VARBNM
C     .. Array Arguments ..
      CHARACTER*(*)           REC(*)
C     .. Local Scalars ..
      INTEGER                 I, NERR, VARLEN
      CHARACTER*72            MESS
C     .. External Subroutines ..
      EXTERNAL                P01ABZ, X04AAF, X04BAF
C     .. Intrinsic Functions ..
      INTRINSIC               ABS, LEN, MOD
C     .. Executable Statements ..
      IF (IERROR.NE.0) THEN
         VARLEN = 0
         DO 20 I = LEN(VARBNM), 1, -1
            IF (VARBNM(I:I).NE.' ') THEN
               VARLEN = I
               GO TO 40
            END IF
   20    CONTINUE
   40    CONTINUE
C        Abnormal exit from calling routine
         IF (IFAIL.EQ.-1 .OR. IFAIL.EQ.0 .OR. IFAIL.EQ.-13 .OR.
     *       (IFAIL.GT.0 .AND. MOD(IFAIL/10,10).NE.0)) THEN
C           Noisy exit
            CALL X04AAF(0,NERR)
            DO 60 I = 1, NREC
               CALL X04BAF(NERR,REC(I))
   60       CONTINUE
            IF (IFAIL.NE.-13) THEN
               IF (VARLEN.NE.0) THEN
                  WRITE (MESS,FMT=99999) SRNAME, VARBNM(1:VARLEN),
     *              IERROR
               ELSE
                  WRITE (MESS,FMT=99998) SRNAME
               END IF
               CALL X04BAF(NERR,MESS)
               IF (ABS(MOD(IFAIL,10)).NE.1) THEN
C                 Hard failure
                  CALL X04BAF(NERR,
     *                     ' ** NAG hard failure - execution terminated'
     *                        )
                  CALL P01ABZ
               ELSE
C                 Soft failure
                  CALL X04BAF(NERR,
     *                        ' ** NAG soft failure - control returned')
               END IF
            END IF
         END IF
      END IF
      P01ACF = IERROR
      RETURN
C
99999 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A,': ',A,
     *       ' =',I6)
99998 FORMAT (' ** ABNORMAL EXIT from NAG Library routine ',A)
      END
      DOUBLE PRECISION FUNCTION X02AJF()
      IMPLICIT NONE
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS  (1/2)*B**(1-P)  IF ROUNDS IS .TRUE.
C     RETURNS  B**(1-P)  OTHERWISE
C
      DOUBLE PRECISION X02CON
      INTEGER ICON(2)
      EQUIVALENCE (ICON,X02CON)
      DATA ICON /Z'00000020', Z'3CA00400' /
C     .. Executable Statements ..
      X02AJF = X02CON
      RETURN
      END
      DOUBLE PRECISION FUNCTION X02AMF()
C     MARK 12 RELEASE. NAG COPYRIGHT 1986.
C
C     RETURNS THE 'SAFE RANGE' PARAMETER
C     I.E. THE SMALLEST POSITIVE MODEL NUMBER Z SUCH THAT
C     FOR ANY X WHICH SATISFIES X.GE.Z AND X.LE.1/Z
C     THE FOLLOWING CAN BE COMPUTED WITHOUT OVERFLOW, UNDERFLOW OR OTHER
C     ERROR
C
C        -X
C        1.0/X
C        SQRT(X)
C        LOG(X)
C        EXP(LOG(X))
C        Y**(LOG(X)/LOG(Y)) FOR ANY Y
C
      DOUBLE PRECISION X02CON
      INTEGER ICON(2)
      EQUIVALENCE (ICON,X02CON)
CDU   DATA X02CON /Z'0010000000000000' /
CLin  DATA X02CON /Z'0010000000000011' /
      DATA ICON /Z'00000011', Z'00100000' /
C     .. Executable Statements ..
      X02AMF = X02CON
      RETURN
      END
      SUBROUTINE X04AAF(I,NERR)
C     MARK 7 RELEASE. NAG COPYRIGHT 1978
C     MARK 7C REVISED IER-190 (MAY 1979)
C     MARK 11.5(F77) REVISED. (SEPT 1985.)
C     MARK 14 REVISED. IER-829 (DEC 1989).
C     IF I = 0, SETS NERR TO CURRENT ERROR MESSAGE UNIT NUMBER
C     (STORED IN NERR1).
C     IF I = 1, CHANGES CURRENT ERROR MESSAGE UNIT NUMBER TO
C     VALUE SPECIFIED BY NERR.
C
C     .. Scalar Arguments ..
      INTEGER           I, NERR
C     .. Local Scalars ..
      INTEGER           NERR1
C     .. Save statement ..
      SAVE              NERR1
C     .. Data statements ..
      DATA              NERR1/6/
C     .. Executable Statements ..
      IF (I.EQ.0) NERR = NERR1
      IF (I.EQ.1) NERR1 = NERR
      RETURN
      END
      SUBROUTINE X04BAF(NOUT,REC)
C     MARK 11.5(F77) RELEASE. NAG COPYRIGHT 1986.
C
C     X04BAF writes the contents of REC to the unit defined by NOUT.
C
C     Trailing blanks are not output, except that if REC is entirely
C     blank, a single blank character is output.
C     If NOUT.lt.0, i.e. if NOUT is not a valid Fortran unit identifier,
C     then no output occurs.
C
C     .. Scalar Arguments ..
      INTEGER           NOUT
      CHARACTER*(*)     REC
C     .. Local Scalars ..
      INTEGER           I
C     .. Intrinsic Functions ..
      INTRINSIC         LEN
C     .. Executable Statements ..
      IF (NOUT.GE.0) THEN
C        Remove trailing blanks
         DO 20 I = LEN(REC), 2, -1
            IF (REC(I:I).NE.' ') GO TO 40
   20    CONTINUE
C        Write record to external file
   40    WRITE (NOUT,FMT=99999) REC(1:I)
      END IF
      RETURN
C
99999 FORMAT (A)
      END
